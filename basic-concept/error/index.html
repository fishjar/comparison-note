<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>错误处理</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>错误处理</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="go" autoComplete="off"/>go</label><label class="btn btn-secondary"><input type="checkbox" value="rust" autoComplete="off"/>rust</label></div></div></div></div><div class="card-group"></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"error","fullPath":"/basic-concept/error","asPath":"/basic-concept/error","id":"%2Fbasic-concept%2Ferror","parent":{"name":"basic-concept","fullPath":"/basic-concept","asPath":"/basic-concept","id":"%2Fbasic-concept","readme":{"title":"基础概念","fullPath":"/basic-concept/README.md"}},"readme":{"title":"错误处理","fullPath":"/basic-concept/error/README.md"},"cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/basic-concept/error/go.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/basic-concept/error/rust.md"}],"nodes":[]},"content":"","cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/basic-concept/error/go.md","content":"## 错误包装\n\n`Wrap` 和 `WrapWithCode` 则是错误二次包装函数，用于将底层的错误包装为新的错误，但是保留的原始的底层错误信息。\n\n```go\nimport (\n    \"github.com/chai2010/errors\"\n)\n\nfunc loadConfig() error {\n    _, err := ioutil.ReadFile(\"/path/to/file\")\n    if err != nil {\n        return errors.Wrap(err, \"read failed\")\n    }\n\n    // ...\n}\n\nfunc setup() error {\n    err := loadConfig()\n    if err != nil {\n        return errors.Wrap(err, \"invalid config\")\n    }\n\n    // ...\n}\n\nfunc main() {\n    if err := setup(); err != nil {\n        log.Fatal(err)\n    }\n\n    // ...\n}\n```\n\n遍历原始错误经历了哪些包装流程：\n\n```go\n    for i, e := range err.(errors.Error).Wraped() {\n        fmt.Printf(\"wrapped(%d): %v\\n\", i, e)\n    }\n```\n\n获取每个包装错误的函数调用堆栈信息：\n\n```go\n    for i, x := range err.(errors.Error).Caller() {\n        fmt.Printf(\"caller:%d: %s\\n\", i, x.FuncName)\n    }\n```\n\n用 errors.ToJson(err) 编码为 JSON 字符串：\n\n```go\n// 以 JSON 字符串方式发送错误\nfunc sendError(ch chan\u003c- string, err error) {\n    ch \u003c- errors.ToJson(err)\n}\n\n// 接收 JSON 字符串格式的错误\nfunc recvError(ch \u003c-chan string) error {\n    p, err := errors.FromJson(\u003c-ch)\n    if err != nil {\n        log.Fatal(err)\n    }\n    return p\n}\n```\n\n给错误绑定一个对应的 http 状态码：\n\n```go\nerr := errors.NewWithCode(404, \"http error code\")\n\nfmt.Println(err)\nfmt.Println(err.(errors.Error).Code())\n```\n"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/basic-concept/error/rust.md","content":"- 可恢复错误 `Result\u003cT, E\u003e`\n- 不可恢复(遇到错误时停止程序执行)错误 `panic!`\n\n## 标准输出/标准错误\n\n大部分终端都提供了两种输出：\n\n- 标准输出（standard output，`stdout`）对应一般信息，\n- 标准错误（standard error，`stderr`）则用于错误信息。\n\n这种区别允许用户选择将程序正常输出定向到一个文件中并仍将错误信息打印到屏幕上。\n但是 `println!` 函数只能够打印到标准输出，所以我们必须使用其他方法来打印到标准错误。\n标准库提供了 `eprintln!` 宏来打印到标准错误流。\n\n```rust\nfn main() {\n    let args: Vec\u003cString\u003e = env::args().collect();\n    let config = Config::new(\u0026args).unwrap_or_else(|err| {\n        eprintln!(\"Problem parsing arguments: {}\", err);\n        process::exit(1);\n    });\n    if let Err(e) = minigrep::run(config) {\n        eprintln!(\"Application error: {}\", e);\n        process::exit(1);\n    }\n}\n```\n\n## 对应 panic 时的栈展开或终止\n\n```toml\n# Cargo.toml\n[profile.release]\npanic = 'abort'\n```\n\n## 使用 panic! 的 backtrace\n\n```sh\nRUST_BACKTRACE=1 cargo run\n```\n\n## Option 和 unwrap\n\n```rust\n// 平民（commoner）们见多识广，收到什么礼物都能应对。\n// 所有礼物都显式地使用 `match` 来处理。\nfn give_commoner(gift: Option\u003c\u0026str\u003e) {\n    // 指出每种情况下的做法。\n    match gift {\n        Some(\"snake\") =\u003e println!(\"Yuck! I'm throwing that snake in a fire.\"),\n        Some(inner)   =\u003e println!(\"{}? How nice.\", inner),\n        None          =\u003e println!(\"No gift? Oh well.\"),\n    }\n}\n\n// 养在深闺人未识的公主见到蛇就会 `panic`（恐慌）。\n// 这里所有的礼物都使用 `unwrap` 隐式地处理。\nfn give_princess(gift: Option\u003c\u0026str\u003e) {\n    // `unwrap` 在接收到 `None` 时将返回 `panic`。\n    let inside = gift.unwrap();\n    if inside == \"snake\" { panic!(\"AAAaaaaa!!!!\"); }\n\n    println!(\"I love {}s!!!!!\", inside);\n}\n\nfn main() {\n    let food  = Some(\"chicken\");\n    let snake = Some(\"snake\");\n    let void  = None;\n\n    give_commoner(food);\n    give_commoner(snake);\n    give_commoner(void);\n\n    let bird = Some(\"robin\");\n    let nothing = None;\n\n    give_princess(bird);\n    give_princess(nothing);\n}\n```\n\n## 使用 `?` 解开 Option\n\n```rust\nfn next_birthday(current_age: Option\u003cu8\u003e) -\u003e Option\u003cString\u003e {\n    // 如果 `current_age` 是 `None`，这将返回 `None`。\n    // 如果 `current_age` 是 `Some`，内部的 `u8` 将赋值给 `next_age`。\n    let next_age: u8 = current_age?;\n    Some(format!(\"Next year I will be {}\", next_age))\n}\n```\n\n```rust\nstruct Person {\n    job: Option\u003cJob\u003e,\n}\n\n#[derive(Clone, Copy)]\nstruct Job {\n    phone_number: Option\u003cPhoneNumber\u003e,\n}\n\n#[derive(Clone, Copy)]\nstruct PhoneNumber {\n    area_code: Option\u003cu8\u003e,\n    number: u32,\n}\n\nimpl Person {\n    // 获取此人的工作电话号码的区号（如果存在的话）。\n    fn work_phone_area_code(\u0026self) -\u003e Option\u003cu8\u003e {\n        // 没有`？`运算符的话，这将需要很多的嵌套的 `match` 语句。\n        // 这将需要更多代码——尝试自己编写一下，看看哪个更容易。\n        self.job?.phone_number?.area_code\n    }\n}\n\nfn main() {\n    let p = Person {\n        job: Some(Job {\n            phone_number: Some(PhoneNumber {\n                area_code: Some(61),\n                number: 439222222,\n            }),\n        }),\n    };\n    assert_eq!(p.work_phone_area_code(), Some(61));\n}\n```\n\n## 组合算子：map\n\n```rust\n#![allow(dead_code)]\n\n#[derive(Debug)] enum Food { Apple, Carrot, Potato }\n\n#[derive(Debug)] struct Peeled(Food);\n#[derive(Debug)] struct Chopped(Food);\n#[derive(Debug)] struct Cooked(Food);\n\n// 削皮。如果没有食物，就返回 `None`。否则返回削好皮的食物。\nfn peel(food: Option\u003cFood\u003e) -\u003e Option\u003cPeeled\u003e {\n    match food {\n        Some(food) =\u003e Some(Peeled(food)),\n        None       =\u003e None,\n    }\n}\n\n// 切食物。如果没有食物，就返回 `None`。否则返回切好的食物。\nfn chop(peeled: Option\u003cPeeled\u003e) -\u003e Option\u003cChopped\u003e {\n    match peeled {\n        Some(Peeled(food)) =\u003e Some(Chopped(food)),\n        None               =\u003e None,\n    }\n}\n\n// 烹饪食物。这里，我们使用 `map()` 来替代 `match` 以处理各种情况。\nfn cook(chopped: Option\u003cChopped\u003e) -\u003e Option\u003cCooked\u003e {\n    chopped.map(|Chopped(food)| Cooked(food))\n}\n\n// 这个函数会完成削皮切块烹饪一条龙。我们把 `map()` 串起来，以简化代码。\nfn process(food: Option\u003cFood\u003e) -\u003e Option\u003cCooked\u003e {\n    food.map(|f| Peeled(f))\n        .map(|Peeled(f)| Chopped(f))\n        .map(|Chopped(f)| Cooked(f))\n}\n\n// 在尝试吃食物之前确认食物是否存在是非常重要的！\nfn eat(food: Option\u003cCooked\u003e) {\n    match food {\n        Some(food) =\u003e println!(\"Mmm. I love {:?}\", food),\n        None       =\u003e println!(\"Oh no! It wasn't edible.\"),\n    }\n}\n\nfn main() {\n    let apple = Some(Food::Apple);\n    let carrot = Some(Food::Carrot);\n    let potato = None;\n\n    let cooked_apple = cook(chop(peel(apple)));\n    let cooked_carrot = cook(chop(peel(carrot)));\n\n    // 现在让我们试试看起来更简单的 `process()`。\n    let cooked_potato = process(potato);\n\n    eat(cooked_apple);\n    eat(cooked_carrot);\n    eat(cooked_potato);\n}\n```\n\n## 组合算子：and_then\n\n```rust\n#![allow(dead_code)]\n\n#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }\n#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }\n\n// 我们没有制作寿司所需的原材料（ingredient）（有其他的原材料）。\nfn have_ingredients(food: Food) -\u003e Option\u003cFood\u003e {\n    match food {\n        Food::Sushi =\u003e None,\n        _           =\u003e Some(food),\n    }\n}\n\n// 我们拥有全部食物的食谱，除了法国蓝带猪排（Cordon Bleu）的。\nfn have_recipe(food: Food) -\u003e Option\u003cFood\u003e {\n    match food {\n        Food::CordonBleu =\u003e None,\n        _                =\u003e Some(food),\n    }\n}\n\n\n// 要做一份好菜，我们需要原材料和食谱。\n// 我们可以借助一系列 `match` 来表达这个逻辑：\nfn cookable_v1(food: Food) -\u003e Option\u003cFood\u003e {\n    match have_ingredients(food) {\n        None       =\u003e None,\n        Some(food) =\u003e match have_recipe(food) {\n            None       =\u003e None,\n            Some(food) =\u003e Some(food),\n        },\n    }\n}\n\n// 也可以使用 `and_then()` 把上面的逻辑改写得更紧凑：\nfn cookable_v2(food: Food) -\u003e Option\u003cFood\u003e {\n    have_ingredients(food).and_then(have_recipe)\n}\n\nfn eat(food: Food, day: Day) {\n    match cookable_v2(food) {\n        Some(food) =\u003e println!(\"Yay! On {:?} we get to eat {:?}.\", day, food),\n        None       =\u003e println!(\"Oh no. We don't get to eat on {:?}?\", day),\n    }\n}\n\nfn main() {\n    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);\n\n    eat(cordon_bleu, Day::Monday);\n    eat(steak, Day::Tuesday);\n    eat(sushi, Day::Wednesday);\n}\n```\n\n## Result 枚举\n\n```rust\nenum Result\u003cT, E\u003e {\n    Ok(T),\n    Err(E),\n}\n```\n\n## Result 的 map\n\n```rust\nuse std::num::ParseIntError;\n\n// 修改了上一节中的返回类型，现在使用模式匹配而不是 `unwrap()`。\nfn multiply(first_number_str: \u0026str, second_number_str: \u0026str) -\u003e Result\u003ci32, ParseIntError\u003e {\n    match first_number_str.parse::\u003ci32\u003e() {\n        Ok(first_number)  =\u003e {\n            match second_number_str.parse::\u003ci32\u003e() {\n                Ok(second_number)  =\u003e {\n                    Ok(first_number * second_number)\n                },\n                Err(e) =\u003e Err(e),\n            }\n        },\n        Err(e) =\u003e Err(e),\n    }\n}\n\nfn print(result: Result\u003ci32, ParseIntError\u003e) {\n    match result {\n        Ok(n)  =\u003e println!(\"n is {}\", n),\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    // 这种情形下仍然会给出正确的答案。\n    let twenty = multiply(\"10\", \"2\");\n    print(twenty);\n\n    // 这种情况下就会提供一条更有用的错误信息。\n    let tt = multiply(\"t\", \"2\");\n    print(tt);\n}\n```\n\n```rust\nuse std::num::ParseIntError;\n\n// 就像 `Option` 那样，我们可以使用 `map()` 之类的组合算子。\n// 除去写法外，这个函数与上面那个完全一致，它的作用是：\n// 如果值是合法的，计算其乘积，否则返回错误。\nfn multiply(first_number_str: \u0026str, second_number_str: \u0026str) -\u003e Result\u003ci32, ParseIntError\u003e {\n    first_number_str.parse::\u003ci32\u003e().and_then(|first_number| {\n        second_number_str.parse::\u003ci32\u003e().map(|second_number| first_number * second_number)\n    })\n}\n\nfn print(result: Result\u003ci32, ParseIntError\u003e) {\n    match result {\n        Ok(n)  =\u003e println!(\"n is {}\", n),\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    // 这种情况下仍然会给出正确的答案。\n    let twenty = multiply(\"10\", \"2\");\n    print(twenty);\n\n    // 这种情况下就会提供一条更有用的错误信息。\n    let tt = multiply(\"t\", \"2\");\n    print(tt);\n}\n```\n\n## 给 Result 取别名\n\n```rust\nuse std::num::ParseIntError;\n\n// 为带有错误类型 `ParseIntError` 的 `Result` 定义一个泛型别名。\ntype AliasedResult\u003cT\u003e = Result\u003cT, ParseIntError\u003e;\n\n// 使用上面定义过的别名来表示上一节中的 `Result\u003ci32,ParseIntError\u003e` 类型。\nfn multiply(first_number_str: \u0026str, second_number_str: \u0026str) -\u003e AliasedResult\u003ci32\u003e {\n    first_number_str.parse::\u003ci32\u003e().and_then(|first_number| {\n        second_number_str.parse::\u003ci32\u003e().map(|second_number| first_number * second_number)\n    })\n}\n\n// 在这里使用别名又让我们节省了一些代码量。\nfn print(result: AliasedResult\u003ci32\u003e) {\n    match result {\n        Ok(n)  =\u003e println!(\"n is {}\", n),\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    print(multiply(\"10\", \"2\"));\n    print(multiply(\"t\", \"2\"));\n}\n```\n\n## 提前返回\n\n```rust\nuse std::num::ParseIntError;\n\nfn multiply(first_number_str: \u0026str, second_number_str: \u0026str) -\u003e Result\u003ci32, ParseIntError\u003e {\n    let first_number = match first_number_str.parse::\u003ci32\u003e() {\n        Ok(first_number)  =\u003e first_number,\n        Err(e) =\u003e return Err(e),\n    };\n\n    let second_number = match second_number_str.parse::\u003ci32\u003e() {\n        Ok(second_number)  =\u003e second_number,\n        Err(e) =\u003e return Err(e),\n    };\n\n    Ok(first_number * second_number)\n}\n\nfn print(result: Result\u003ci32, ParseIntError\u003e) {\n    match result {\n        Ok(n)  =\u003e println!(\"n is {}\", n),\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    print(multiply(\"10\", \"2\"));\n    print(multiply(\"t\", \"2\"));\n}\n```\n\n## 引入 `?`\n\n```rust\nuse std::num::ParseIntError;\n\nfn multiply(first_number_str: \u0026str, second_number_str: \u0026str) -\u003e Result\u003ci32, ParseIntError\u003e {\n    let first_number = first_number_str.parse::\u003ci32\u003e()?;\n    let second_number = second_number_str.parse::\u003ci32\u003e()?;\n\n    Ok(first_number * second_number)\n}\n\nfn print(result: Result\u003ci32, ParseIntError\u003e) {\n    match result {\n        Ok(n)  =\u003e println!(\"n is {}\", n),\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    print(multiply(\"10\", \"2\"));\n    print(multiply(\"t\", \"2\"));\n}\n```\n\n## 定义一个错误类型\n\n```rust\nuse std::error;\nuse std::fmt;\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, DoubleError\u003e;\n\n#[derive(Debug, Clone)]\n// 定义我们的错误类型，这种类型可以根据错误处理的实际情况定制。\n// 我们可以完全自定义错误类型，也可以在类型中完全采用底层的错误实现，\n// 也可以介于二者之间。\nstruct DoubleError;\n\n// 错误的生成与它如何显示是完全没关系的。没有必要担心复杂的逻辑会导致混乱的显示。\n//\n// 注意我们没有储存关于错误的任何额外信息，也就是说，如果不修改我们的错误类型定义的话，\n// 就无法指明是哪个字符串解析失败了。\nimpl fmt::Display for DoubleError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"invalid first item to double\")\n    }\n}\n\n// 为 `DoubleError` 实现 `Error` trait，这样其他错误可以包裹这个错误类型。\nimpl error::Error for DoubleError {\n    fn source(\u0026self) -\u003e Option\u003c\u0026(dyn error::Error + 'static)\u003e {\n        // 泛型错误，没有记录其内部原因。\n        None\n    }\n}\n\nfn double_first(vec: Vec\u003c\u0026str\u003e) -\u003e Result\u003ci32\u003e {\n    vec.first()\n       // 把错误换成我们的新类型。\n       .ok_or(DoubleError)\n       .and_then(|s| {\n            s.parse::\u003ci32\u003e()\n                // 这里也换成新类型。\n                .map_err(|_| DoubleError)\n                .map(|i| 2 * i)\n        })\n}\n\nfn print(result: Result\u003ci32\u003e) {\n    match result {\n        Ok(n)  =\u003e println!(\"The first doubled is {}\", n),\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    let numbers = vec![\"42\", \"93\", \"18\"];\n    let empty = vec![];\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n\n    print(double_first(numbers));\n    print(double_first(empty));\n    print(double_first(strings));\n}\n```\n\n## 把错误 “装箱”\n\n```rust\nuse std::error;\nuse std::fmt;\n\n// 为 `Box\u003cerror::Error\u003e` 取别名。\ntype Result\u003cT\u003e = std::result::Result\u003cT, Box\u003cdyn error::Error\u003e\u003e;\n\n#[derive(Debug, Clone)]\nstruct EmptyVec;\n\nimpl fmt::Display for EmptyVec {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"invalid first item to double\")\n    }\n}\n\nimpl error::Error for EmptyVec {\n    fn description(\u0026self) -\u003e \u0026str {\n        \"invalid first item to double\"\n    }\n\n    fn cause(\u0026self) -\u003e Option\u003c\u0026dyn error::Error\u003e {\n        // 泛型错误。没有记录其内部原因。\n        None\n    }\n}\n\nfn double_first(vec: Vec\u003c\u0026str\u003e) -\u003e Result\u003ci32\u003e {\n    vec.first()\n       .ok_or_else(|| EmptyVec.into())  // 装箱\n       .and_then(|s| {\n            s.parse::\u003ci32\u003e()\n                .map_err(|e| e.into())  // 装箱\n                .map(|i| 2 * i)\n        })\n}\n\nfn print(result: Result\u003ci32\u003e) {\n    match result {\n        Ok(n)  =\u003e println!(\"The first doubled is {}\", n),\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    let numbers = vec![\"42\", \"93\", \"18\"];\n    let empty = vec![];\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n\n    print(double_first(numbers));\n    print(double_first(empty));\n    print(double_first(strings));\n}\n```\n\n## `?` 的其他用法\n\n```rust\nuse std::error;\nuse std::fmt;\n\n// 为 `Box\u003cerror::Error\u003e` 取别名。\ntype Result\u003cT\u003e = std::result::Result\u003cT, Box\u003cdyn error::Error\u003e\u003e;\n\n#[derive(Debug)]\nstruct EmptyVec;\n\nimpl fmt::Display for EmptyVec {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"invalid first item to double\")\n    }\n}\n\nimpl error::Error for EmptyVec {}\n\n// 这里的结构和之前一样，但是这次没有把所有的 `Result` 和 `Option` 串起来，\n// 而是使用 `?` 立即得到内部值。\nfn double_first(vec: Vec\u003c\u0026str\u003e) -\u003e Result\u003ci32\u003e {\n    let first = vec.first().ok_or(EmptyVec)?;\n    let parsed = first.parse::\u003ci32\u003e()?;\n    Ok(2 * parsed)\n}\n\nfn print(result: Result\u003ci32\u003e) {\n    match result {\n        Ok(n)  =\u003e println!(\"The first doubled is {}\", n),\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    let numbers = vec![\"42\", \"93\", \"18\"];\n    let empty = vec![];\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n\n    print(double_first(numbers));\n    print(double_first(empty));\n    print(double_first(strings));\n}\n```\n\n## 包裹错误\n\n```rust\nuse std::error;\nuse std::num::ParseIntError;\nuse std::fmt;\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, DoubleError\u003e;\n\n#[derive(Debug)]\nenum DoubleError {\n    EmptyVec,\n    // 在这个错误类型中，我们采用 `parse` 的错误类型中 `Err` 部分的实现。\n    // 若想提供更多信息，则该类型中还需要加入更多数据。\n    Parse(ParseIntError),\n}\n\nimpl fmt::Display for DoubleError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match *self {\n            DoubleError::EmptyVec =\u003e\n                write!(f, \"please use a vector with at least one element\"),\n            // 这是一个封装（wrapper），它采用内部各类型对 `fmt` 的实现。\n            DoubleError::Parse(ref e) =\u003e e.fmt(f),\n        }\n    }\n}\n\nimpl error::Error for DoubleError {\n    fn source(\u0026self) -\u003e Option\u003c\u0026(dyn error::Error + 'static)\u003e {\n        match *self {\n            DoubleError::EmptyVec =\u003e None,\n            // 原因采取内部对错误类型的实现。它隐式地转换成了 trait 对象 `\u0026error:Error`。\n            // 这可以工作，因为内部的类型已经实现了 `Error` trait。\n            DoubleError::Parse(ref e) =\u003e Some(e),\n        }\n    }\n}\n\n// 实现从 `ParseIntError` 到 `DoubleError` 的转换。\n// 在使用 `?` 时，或者一个 `ParseIntError` 需要转换成 `DoubleError` 时，它会被自动调用。\nimpl From\u003cParseIntError\u003e for DoubleError {\n    fn from(err: ParseIntError) -\u003e DoubleError {\n        DoubleError::Parse(err)\n    }\n}\n\nfn double_first(vec: Vec\u003c\u0026str\u003e) -\u003e Result\u003ci32\u003e {\n    let first = vec.first().ok_or(DoubleError::EmptyVec)?;\n    let parsed = first.parse::\u003ci32\u003e()?;\n\n    Ok(2 * parsed)\n}\n\nfn print(result: Result\u003ci32\u003e) {\n    match result {\n        Ok(n)  =\u003e println!(\"The first doubled is {}\", n),\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n}\n\nfn main() {\n    let numbers = vec![\"42\", \"93\", \"18\"];\n    let empty = vec![];\n    let strings = vec![\"tofu\", \"93\", \"18\"];\n\n    print(double_first(numbers));\n    print(double_first(empty));\n    print(double_first(strings));\n}\n```\n\n## 匹配不同的错误\n\n```rust\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let f = File::open(\"hello.txt\");\n    let f = match f {\n        Ok(file) =\u003e file,\n        Err(error) =\u003e match error.kind() {\n            ErrorKind::NotFound =\u003e match File::create(\"hello.txt\") {\n                Ok(fc) =\u003e fc,\n                Err(e) =\u003e panic!(\"Problem creating the file: {:?}\", e),\n            },\n            other_error =\u003e panic!(\"Problem opening the file: {:?}\", other_error),\n        },\n    };\n}\n```\n\n```rust\n// 更老练的 Rustacean 可能会这么写\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let f = File::open(\"hello.txt\").unwrap_or_else(|error| {\n        if error.kind() == ErrorKind::NotFound {\n            File::create(\"hello.txt\").unwrap_or_else(|error| {\n                panic!(\"Problem creating the file: {:?}\", error);\n            })\n        } else {\n            panic!(\"Problem opening the file: {:?}\", error);\n        }\n    });\n}\n```\n\n## 失败时 panic 的简写：unwrap 和 expect\n\n```rust\nuse std::fs::File;\n\nfn main() {\n    let f = File::open(\"hello.txt\").unwrap();\n    let f = File::open(\"hello.txt\").expect(\"Failed to open hello.txt\");\n}\n```\n\n## 传播错误\n\n```rust\nuse std::io;\nuse std::io::Read;\nuse std::fs::File;\n\nfn read_username_from_file() -\u003e Result\u003cString, io::Error\u003e {\n    let f = File::open(\"hello.txt\");\n    let mut f = match f {\n        Ok(file) =\u003e file,\n        Err(e) =\u003e return Err(e), // 错误直接返回\n    };\n\n    let mut s = String::new();\n    match f.read_to_string(\u0026mut s) {\n        Ok(_) =\u003e Ok(s),\n        Err(e) =\u003e Err(e),\n    }\n}\n\n// 简写\nfn read_username_from_file() -\u003e Result\u003cString, io::Error\u003e {\n    let mut f = File::open(\"hello.txt\")?;\n    let mut s = String::new();\n    f.read_to_string(\u0026mut s)?;\n    Ok(s)\n}\n\n// 简写\nfn new(mut args: std::env::Args) -\u003e Result\u003cConfig, \u0026'static str\u003e {\n    args.next();\n    // let query = match args.next() {\n    //     Some(arg) =\u003e arg,\n    //     None =\u003e return Err(\"Didn't get a query string\"),\n    // };\n    let query = args.next().ok_or(\"Didn't get a query string\")?;\n    Ok(Config {\n        query,\n    })\n}\n\n// 链式方法调用\nfn read_username_from_file() -\u003e Result\u003cString, io::Error\u003e {\n    let mut s = String::new();\n    File::open(\"hello.txt\")?.read_to_string(\u0026mut s)?;\n    Ok(s)\n}\n\n// 使用 fs::read_to_string\nfn read_username_from_file() -\u003e Result\u003cString, io::Error\u003e {\n    fs::read_to_string(\"hello.txt\")\n}\n```\n\n```rust\nuse std::fs::File;\nfn main() {\n    // 只能在返回 Result 或者其它实现了 std::ops::Try 的类型的函数中使用 ? 运算符。\n    let f = File::open(\"hello.txt\")?; // 错误\n}\n```\n\n```rust\nuse std::error::Error;\nuse std::fs::File;\n// main 函数是特殊的，其必须返回什么类型是有限制的。\n// main 函数的一个有效的返回值是 ()，\n// 同时出于方便，另一个有效的返回值是 Result\u003cT, E\u003e\nfn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    let f = File::open(\"hello.txt\")?;\n    Ok(())\n}\n```\n"}]}},"page":"/[...param]","query":{"param":["basic-concept","error"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"错误处理"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>