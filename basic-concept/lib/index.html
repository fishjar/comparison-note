<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>库/包/模块</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>库/包/模块</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="c" autoComplete="off"/>c</label><label class="btn btn-secondary"><input type="checkbox" value="dart" autoComplete="off"/>dart</label><label class="btn btn-secondary"><input type="checkbox" value="go" autoComplete="off"/>go</label><label class="btn btn-secondary"><input type="checkbox" value="js" autoComplete="off"/>js</label><label class="btn btn-secondary"><input type="checkbox" value="python" autoComplete="off"/>python</label><label class="btn btn-secondary"><input type="checkbox" value="rust" autoComplete="off"/>rust</label></div></div></div></div><div class="card-group"></div><div style="margin-top:12px" class="card"><div class="card-body"><h6>了解更多</h6><ul><li><a href="/comparison-note/basic-concept/lib/lib-dir/">项目结构</a><span style="color:#666"> [dart, go, js, python, rust]</span></li><li><a href="/comparison-note/basic-concept/lib/lib-tools/">包管理</a><span style="color:#666"> [dart, python, rust]</span></li></ul></div></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"lib","fullPath":"/basic-concept/lib","asPath":"/basic-concept/lib","id":"%2Fbasic-concept%2Flib","parent":{"name":"basic-concept","fullPath":"/basic-concept","asPath":"/basic-concept","id":"%2Fbasic-concept","readme":{"title":"基础概念","fullPath":"/basic-concept/README.md"}},"readme":{"title":"库/包/模块","fullPath":"/basic-concept/lib/README.md"},"cards":[{"name":"c.md","baseName":"c","extName":".md","fullPath":"/basic-concept/lib/c.md"},{"name":"dart.md","baseName":"dart","extName":".md","fullPath":"/basic-concept/lib/dart.md"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/basic-concept/lib/go.md"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/basic-concept/lib/js.md"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/basic-concept/lib/python.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/basic-concept/lib/rust.md"}],"nodes":[{"name":"lib-dir","fullPath":"/basic-concept/lib/lib-dir","asPath":"/basic-concept/lib/lib-dir","id":"%2Fbasic-concept%2Flib%2Flib-dir","parent":{"name":"lib","fullPath":"/basic-concept/lib","asPath":"/basic-concept/lib","id":"%2Fbasic-concept%2Flib","readme":{"title":"库/包/模块","fullPath":"/basic-concept/lib/README.md"}},"readme":{"title":"项目结构","fullPath":"/basic-concept/lib/lib-dir/README.md"},"cards":[{"name":"dart.md","baseName":"dart","extName":".md","fullPath":"/basic-concept/lib/lib-dir/dart.md"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/basic-concept/lib/lib-dir/go.md"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/basic-concept/lib/lib-dir/js.md"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/basic-concept/lib/lib-dir/python.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/basic-concept/lib/lib-dir/rust.md"}],"nodes":[]},{"name":"lib-tools","fullPath":"/basic-concept/lib/lib-tools","asPath":"/basic-concept/lib/lib-tools","id":"%2Fbasic-concept%2Flib%2Flib-tools","parent":{"name":"lib","fullPath":"/basic-concept/lib","asPath":"/basic-concept/lib","id":"%2Fbasic-concept%2Flib","readme":{"title":"库/包/模块","fullPath":"/basic-concept/lib/README.md"}},"readme":{"title":"包管理","fullPath":"/basic-concept/lib/lib-tools/README.md"},"cards":[{"name":"dart.md","baseName":"dart","extName":".md","fullPath":"/basic-concept/lib/lib-tools/dart.md"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/basic-concept/lib/lib-tools/python.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/basic-concept/lib/lib-tools/rust.md"}],"nodes":[]}]},"content":"","cards":[{"name":"c.md","baseName":"c","extName":".md","fullPath":"/basic-concept/lib/c.md","content":"## 引用自定义库\n\n```c++\n// File foo.c\n\n#include \u003cstdio.h\u003e\n#include \"bar.h\"\n\nint main(void) {\n  printf(\"%d\\n\", add(2, 3));  // 5!\n}\n```\n\n```c++\n// File bar.h\n#ifndef BAR_H\n  #define BAR_H\n  int add(int, int);\n#endif\n```\n\n```c++\n// File bar.c\n#include \"bar.h\"\n\nint add(int a, int b) {\n  return a + b;\n}\n```\n\n```sh\ngcc -o foo foo.c bar.c\n```\n\n## 分步编译\n\n```sh\ngcc -c foo.c # 生成 foo.o\ngcc -c bar.c # 生成 bar.o\ngcc -o foo foo.o bar.o # 链接，合并生成一个可执行文件\n```\n\n## make\n\n```makefile\nfoo: foo.o bar.o\n  gcc -o foo foo.o bar.o\n\nfoo.o: bar.h foo.c\n  gcc -c foo.c\n\nbar.o: bar.h bar.c\n  gcc -c bar.c\n```\n\n```sh\nmake foo.o\nmake bar.o\nmake foo\nmake # 默认执行第一条编译规则\n```\n"},{"name":"dart.md","baseName":"dart","extName":".md","fullPath":"/basic-concept/lib/dart.md","content":"Dart 有两种类型的包： 应用 包 和 库 包。\n\n最简单的库包的 目录结构：\n通常情况下都把实现代码放到 `lib/src` 目录中。\n位于 `lib/src` 下面的代码被认为是私有的；\n其他包不应该直接导入 `src/...` 里面的代码。\n\n要分享 lib/src 下的 API，你可以在 lib 目录下 创建一个文件，\n在这个文件中导入 lib/src 中的代码。\n\n```sh\nroot ------lib-----file.dart\n        |--pubspec.yaml\n```\n\n- 库不仅仅提供 API， 还是一个私有单元：\n  以下划线 (\\_) 开头的标识符只有在库 内部可见。\n  每个 Dart app 都是一个库， 即使没有使用 library 命令也是一个库\n- import 必须参数为库 的 URI。\n  对于内置的库，URI 使用特殊的 dart: scheme。\n  对于其他的库，你可以使用文件系统路径或者 package: scheme。\n  package: scheme 指定的库通过包管理器来提供， 例如 pub 工具。\n\n```dart\nimport 'dart:html';\nimport 'dart:io';\nimport 'package:mylib/mylib.dart';\nimport 'package:utils/utils.dart';\n\n// Specifying a library prefix（指定库前缀）\nimport 'package:lib1/lib1.dart';\nimport 'package:lib2/lib2.dart' as lib2;\n// ...\nElement element1 = new Element();           // Uses Element from lib1.\nlib2.Element element2 = new lib2.Element(); // Uses Element from lib2.\n\n// Importing only part of a library（导入库的一部分）\n// Import only foo.\nimport 'package:lib1/lib1.dart' show foo;\n// Import all names EXCEPT foo.\nimport 'package:lib2/lib2.dart' hide foo;\n\n// Lazily loading a library（延迟载入库）\n// 可以多次调用 loadLibrary() 函数。 但是该库只是载入一次\nimport 'package:deferred/hello.dart' deferred as hello;\ngreet() async {\n  await hello.loadLibrary();\n  hello.printGreeting();\n}\n\n\nimport 'french.dart';\nexport 'french.dart' show hello;\n\n// 引入某个库的多个对象\nimport 'package:flutter/material.dart' show StatefulWidget, StatelessWidget;\n```\n"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/basic-concept/lib/go.md","content":"每个源文件都是以包的声明语句开始，用来指明包的名字。\n当包被导入的时候，包内的成员将通过类似 tempconv.CToF 的形式访问。\n而包级别的名字，例如在一个文件声明的类型和常量，\n在同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。\n\nGo 语言的代码通过包（package）组织，\n包类似于其它语言里的库（libraries）或者模块（modules）。\n一个包由位于单个目录下的一个或多个.go 源代码文件组成, 目录定义包的作用。\n每个源文件都以一条 package 声明语句开始，这个例子里就是 package main,\n表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。\n\n在 Go 语言程序中，每个包都有一个全局唯一的导入路径。\n一个导入路径代表一个目录中的一个或多个 Go 源文件。\n\nGo 的标准库提供了 100 多个包，以支持常见功能，如输入、输出、排序以及文本处理。\n\nmain 包比较特殊。它定义了一个独立可执行的程序，而不是一个库。\n\n此代码用圆括号组合了导入，这是“分组”形式的导入语句。\n不过使用分组导入语句是更好的形式。\n\n在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。\n例如，Pizza 就是个已导出名，Pi 也同样，它导出自 math 包。\npizza 和 pi 并未以大写字母开头，所以它们是未导出的。\n在导入一个包时，你只能引用其中已导出的名字。\n任何“未导出”的名字在该包外均无法访问。\n\n言外之意，\n\n- 大写字母开头的变量会导出给其他包使用，\n- 小写字母开头的变量为包内私有，不会导出\n\n- Go 源文件中的第一个语句必须是 `package 名称`\n- 这里的 名称 即为导入该包时使用的默认名称。 （一个包中的所有文件都必须使用相同的 名称。）\n- Go 的约定是包名为导入路径的最后一个元素：作为 “crypto/rot13” 导入的包应命名为 rot13。\n- 可执行命令必须使用 `package main`。\n- 链接成单个二进制文件的所有包，其包名无需是唯一的，只有导入路径（它们的完整文件名） 才是唯一的。\n\n在 `src/pkg/encoding/base64` 中的包应作为 `encoding/base64` 导入，\n\n```go\nimport (\n  \"fmt\"\n  \"math\"\n)\n// 等同于\nimport \"fmt\"\nimport \"math\"\n\n// 别名操作\nimport(\n  f \"fmt\"\n)\n\n// math包内的Pi即为导出的\nfunc main() {\n  fmt.Println(math.Pi)\n}\n```\n\n```sh\n# 若你在包的导入路径中包含了代码仓库的URL，go get 就会自动地获取、 构建并安装它：\n$ go get github.com/golang/example/hello\n$ $GOPATH/bin/hello\nHello, Go examples!\n\n# 在执行完上面的go get 命令后，工作空间的目录树看起来应该是这样的：\nbin/\n    hello                           # command executable\nsrc/\n    github.com/golang/example/\n        .git/                       # Git repository metadata\n        hello/\n            hello.go                # command source\n        stringutil/\n            reverse.go              # package source\n            reverse_test.go         # test source\n    github.com/user/\n        hello/\n            hello.go                # command source\n        stringutil/\n            reverse.go              # package source\n            reverse_test.go         # test source\n```\n"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/basic-concept/lib/js.md","content":"- 一个 Node.js 文件就是一个模块\n- 包是在模块基础上更深一步的抽象，使用 npm 来解决包的发布和获取，\n  `package.json`必须在包的顶层目录下\n\n```js\nimport { stat, exists, readFile } from \"fs\";\nimport _, { each, forEach } from \"lodash\";\n// 整体加载的写法\nimport * as circle from \"./circle\";\n\n// profile.js\nexport var firstName = \"Michael\";\nexport var lastName = \"Jackson\";\nexport var year = 1958;\n\n// profile.js\nvar firstName = \"Michael\";\nvar lastName = \"Jackson\";\nvar year = 1958;\nexport { firstName, lastName, year };\n\n// export-default.js\nexport default function() {\n  console.log(\"foo\");\n}\n// import-default.js\nimport customName from \"./export-default\";\ncustomName(); // 'foo'\n\nexport { foo, bar } from \"my_module\";\n// 可以简单理解为\nimport { foo, bar } from \"my_module\";\nexport { foo, bar };\n```\n"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/basic-concept/lib/python.md","content":"- `module`：一个文件就是一个模块\n- `package`：包是一个包含 `__init__.py` 文件的目录\n  包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法。\n- `lib`：库是完成一定功能的代码集合，在 python 中是包和模块的形式\n\n当一个名为 spam 的模块被导入的时候，\n解释器首先寻找具有该名称的内置模块。\n如果没有找到，然后解释器从 `sys.path` 变量给出的目录列表里寻找名为 `spam.py` 的文件。\n`sys.path` 初始有这些目录地址:\n\n- 包含输入脚本的目录（或者未指定文件时的当前目录）。\n- PYTHONPATH （一个包含目录名称的列表，它和 shell 变量 PATH 有一样的语法）。\n- 取决于安装的默认设置\n\n```python\n# fibo.py\ndef fib(n):    # write Fibonacci series up to n\n  a, b = 0, 1\n  while a \u003c n:\n    print(a, end=' ')\n    a, b = b, a+b\n  print()\ndef fib2(n):   # return Fibonacci series up to n\n  result = []\n  a, b = 0, 1\n  while a \u003c n:\n    result.append(a)\n    a, b = b, a+b\n  return result\n\n#\nimport fibo\nfibo.fib(1000)\n#\nfrom fibo import fib, fib2\nfib(1000)\n#\nfrom fibo import *\nfib(1000)\n#\nimport fibo as fib\nfib.fib(500)\n#\nfrom fibo import fib as fibonacci\nfibonacci(500)\n\n# 以脚本的方式执行模块\n# python fibo.py \u003carguments\u003e\nif __name__ == \"__main__\":\n    import sys\n    fib(int(sys.argv[1]))\n\n# 子包参考\nfrom . import echo\nfrom .. import formats\nfrom ..filters import equalizer\n```\n"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/basic-concept/lib/rust.md","content":"- 包（Packages）： Cargo 的一个功能，它允许你构建、测试和分享 crate。\n  - 包（package） 是提供一系列功能的一个或者多个 crate。\n  - 一个包会包含有一个 Cargo.toml 文件，阐述如何去构建这些 crate。\n    - 一个包中至多 只能 包含一个库 crate(library crate)；\n    - 包中可以包含任意多个二进制 crate(binary crate)；\n    - 包中至少包含一个 crate，无论是库的还是二进制的。\n- Crates ：一个模块的树形结构，它形成了库或二进制项目。\n  - Cargo 遵循的一个约定：\n    - `src/main.rs` 就是一个与包同名的二进制 crate 的 crate 根。\n    - `src/lib.rs`，则包带有与其同名的库 crate，且 `src/lib.rs` 是 crate 根\n    - 如果一个包同时含有 `src/main.rs` 和 `src/lib.rs`，则它有两个 crate：一个库和一个二进制项，且名字都与包相同。\n    - 通过将文件放在 `src/bin` 目录下，一个包可以拥有多个二进制 crate：每个 `src/bin` 下的文件都会被编译成一个独立的二进制 crate。\n- 模块（Modules）和 use： 允许你控制作用域和路径的私有性。\n  - 模块 让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。\n  - 模块还可以控制项的 私有性，即项是可以被外部代码使用的（public）\n- 路径（path）：一个命名例如结构体、函数或模块等项的方式\n\n```sh\n# 创建一个新的名为 restaurant 的库\ncargo new --lib restaurant\n```\n\n```sh\n# 模块树\ncrate\n └── front_of_house\n     ├── hosting\n     │   ├── add_to_waitlist\n     │   └── seat_at_table\n     └── serving\n         ├── take_order\n         ├── serve_order\n         └── take_payment\n```\n\n```rust\n// src/lib.rs\n#![allow(unused)]\nfn main() {\n    mod front_of_house {\n        mod hosting { // 模块嵌套\n            fn add_to_waitlist() {}\n\n            fn seat_at_table() {}\n        }\n\n        mod serving {\n            fn take_order() {}\n\n            fn server_order() {}\n\n            fn take_payment() {}\n        }\n    }\n}\n```\n\n## crate\n\n- crate（中文有 “包，包装箱” 之意）是 Rust 的编译单元。\n  - 当调用 `rustc some_file.rs` 时，`some_file.rs` 被当作 crate 文件。\n  - 如果 `some_file.rs` 里面含有 `mod` 声明，那么模块文件的内容将在编译之前被插入 crate 文件的相应声明处。\n  - 换句话说，模块不会单独被编译，只有 crate 才会被编译。\n  - crate 可以编译成二进制可执行文件（binary）或库文件（library）。\n\n## 库（library）\n\n- 默认情况 下，rustc 将从 crate 产生二进制可执行文件。\n- 这种行为可以通过 rustc 的选项 `--crate-type` 重载。\n\n```sh\n# 编译一个库\nrustc --crate-type=lib rary.rs # 生成 library.rlib\n# library.rlib 是已编译好的库的路径，这里假设它在同一目录下：\n\n# 链接一个已编译好的库，并编译成可执行文件\nrustc executable.rs --extern rary=library.rlib --edition=2018 \u0026\u0026 ./executable\n```\n\n```rust\n// rary.rs\npub fn public_function() {\n    println!(\"called rary's `public_function()`\");\n}\nfn private_function() {\n    println!(\"called rary's `private_function()`\");\n}\npub fn indirect_access() {\n    print!(\"called rary's `indirect_access()`, that\\n\u003e \");\n\n    private_function();\n}\n```\n\n```rust\n// executable.rs\n// extern crate rary; // 在 Rust 2015 版或更早版本需要这个导入语句\nfn main() {\n    rary::public_function();\n    // 报错！ `private_function` 是私有的\n    //rary::private_function();\n    rary::indirect_access();\n}\n```\n\n## 模块路径的两种形式\n\n- 绝对路径（absolute path）从 crate 根部开始，以 crate 名或者字面量 crate 开头。\n- 相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。\n\n```rust\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n```\n\n### 使用 super 起始的相对路径\n\n```rust\nfn serve_order() {}\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        super::serve_order();\n    }\n    fn cook_order() {}\n}\n```\n\n## 创建公有的结构体和枚举\n\n```rust\nmod back_of_house {\n    // 如果我们在一个结构体定义的前面使用了 pub ，\n    // 这个结构体会变成公有的，但是这个结构体的字段仍然是私有的。\n    pub struct Breakfast {\n        pub toast: String,\n        seasonal_fruit: String,\n    }\n\n    impl Breakfast {\n        // 想当于静态方法\n        pub fn summer(toast: \u0026str) -\u003e Breakfast {\n            Breakfast {\n                toast: String::from(toast),\n                seasonal_fruit: String::from(\"peaches\"),\n            }\n        }\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Order a breakfast in the summer with Rye toast\n    let mut meal = back_of_house::Breakfast::summer(\"Rye\");\n    // Change our mind about what bread we'd like\n    meal.toast = String::from(\"Wheat\"); // 公有字段\n    println!(\"I'd like {} toast please\", meal.toast);\n\n    // The next line won't compile if we uncomment it; we're not allowed\n    // to see or modify the seasonal fruit that comes with the meal\n    // meal.seasonal_fruit = String::from(\"blueberries\"); // 私有字段\n}\n```\n\n```rust\nmod back_of_house {\n    // 如果我们将枚举设为公有，则它的所有成员都将变为公有。\n    pub enum Appetizer {\n        Soup,\n        Salad,\n    }\n}\n\npub fn eat_at_restaurant() {\n    let order1 = back_of_house::Appetizer::Soup;\n    let order2 = back_of_house::Appetizer::Salad;\n}\n```\n\n## 使用 use 关键字将名称引入作用域\n\n```rust\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting::add_to_waitlist;\n\npub fn eat_at_restaurant() {\n    add_to_waitlist();\n    add_to_waitlist();\n    add_to_waitlist();\n}\nfn main() {}\n```\n\n```rust\n#![allow(unused)]\nfn main() {\n    use std::fmt::Result;\n    use std::io::Result as IoResult;\n\n    fn function1() -\u003e Result {\n        // --snip--\n        Ok(())\n    }\n\n    fn function2() -\u003e IoResult\u003c()\u003e {\n        // --snip--\n        Ok(())\n    }\n}\n```\n\n```rust\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\n// 使用 pub use 重导出名称\npub use crate::front_of_house::hosting; // 引入并导出\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n}\nfn main() {}\n```\n\n## 使用 as 关键字提供新的名称\n\n```rust\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\n\nfn function1() -\u003e Result {\n    // --snip--\n}\n\nfn function2() -\u003e IoResult\u003c()\u003e {\n    // --snip--\n}\n```\n\n## 使用外部包\n\n```toml\n[dependencies]\nrand = \"0.8.3\"\n```\n\n```rust\nuse rand::Rng;\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1..101);\n}\n```\n\n```rust\nuse std::cmp::Ordering;\nuse std::io;\n\n// 与上面写法相同\nuse std::{cmp::Ordering, io};\n\n\nuse std::io;\nuse std::io::Write;\n\n// 与上面写法相同\nuse std::io::{self, Write};\n\n// 将一个路径下 所有 公有项引入作用域\nuse std::collections::*;\n```\n\n## 将模块分割进不同文件\n\n```rust\n// src/lib.rs\n\n// 在 mod front_of_house 后使用分号，而不是代码块，\n// 这将告诉 Rust 在另一个与模块同名的文件中加载模块的内容。\nmod front_of_house;\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n}\n```\n\n```rust\n// src/front_of_house.rs\n\n// pub mod hosting {\n//     pub fn add_to_waitlist() {}\n// }\n\n// 继续重构，将 hosting 模块也提取到其自己的文件中\npub mod hosting;\n```\n\n```rust\n// src/front_of_house/hosting.rs\npub fn add_to_waitlist() {}\n```\n\n## 使用 pub use 导出合适的公有 API\n\n```rust\n// src/lib.rs\n//! # Art\n//!\n//! A library for modeling artistic concepts.\n\npub mod kinds {\n    /// The primary colors according to the RYB color model.\n    pub enum PrimaryColor {\n        Red,\n        Yellow,\n        Blue,\n    }\n\n    /// The secondary colors according to the RYB color model.\n    pub enum SecondaryColor {\n        Orange,\n        Green,\n        Purple,\n    }\n}\n\npub mod utils {\n    use crate::kinds::*;\n\n    /// Combines two primary colors in equal amounts to create\n    /// a secondary color.\n    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -\u003e SecondaryColor {\n        // --snip--\n    }\n}\n```\n\n```rust\n// src/main.rs\nuse art::kinds::PrimaryColor; // 全路径\nuse art::utils::mix;\n\nfn main() {\n    let red = PrimaryColor::Red;\n    let yellow = PrimaryColor::Yellow;\n    mix(red, yellow);\n}\n```\n\n使用 pub use 语句导出\n\n```rust\n// src/lib.rs\n//! # Art\n//!\n//! A library for modeling artistic concepts.\n\npub use self::kinds::PrimaryColor;\npub use self::kinds::SecondaryColor;\npub use self::utils::mix;\n\npub mod kinds {\n    // --snip--\n}\n\npub mod utils {\n    // --snip--\n}\n```\n\n```rust\n// src/main.rs\nuse art::PrimaryColor; // 导出后路径变短\nuse art::mix;\n\nfn main() {\n    // --snip--\n}\n```\n\n## 工作空间\n\n### 创建工作空间\n\n```sh\nmkdir add\ncd add\ncargo new adder\ncargo new add-one --lib\n\n# 构建整个工作空间\ncargo build\n```\n\n- 这个 `Cargo.toml` 文件配置了整个工作空间。\n- 它不会包含 `[package]` 或其他我们在 `Cargo.toml` 中见过的元信息。\n- 相反，它以 `[workspace]` 部分作为开始，并通过指定 `adder` 的路径来为工作空间增加成员\n- 工作空间只在根目录有一个`Cargo.lock`，而不是在每一个 `crate` 目录都有 `Cargo.lock`。\n  - 这确保了所有的 `crate` 都使用完全相同版本的依赖。\n- `adder` 并没有自己的 `target` 目录\n- 即使进入 `adder` 目录运行 `cargo build`，构建结果也位于 `add/target` 而不是 `add/adder/target`\n- 如果你选择向 `crates.io` 发布工作空间中的 `crate`，每一个工作空间中的 `crate` 需要单独发布。\n  - 必须进入每一个 crate 的目录并运行 `cargo publish` 来发布工作空间中的每一个 crate。\n\n```toml\n# Cargo.toml\n[workspace]\nmembers = [\n    \"adder\",\n    \"add-one\",\n]\n```\n\n```sh\n├── Cargo.lock\n├── Cargo.toml\n├── add-one\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n├── adder\n│   ├── Cargo.toml\n│   └── src\n│       └── main.rs\n└── target\n```\n\n### 调用工作空间的 create\n\n```rust\n// add-one/src/lib.rs\npub fn add_one(x: i32) -\u003e i32 {\n    x + 1\n}\n```\n\n```toml\n# adder/Cargo.toml\n[dependencies]\nadd-one = { path = \"../add-one\" }\n```\n\n```rust\n// adder/src/main.rs\nuse add_one;\nfn main() {\n    let num = 10;\n    println!(\"Hello, world! {} plus one is {}!\", num, add_one::add_one(num));\n}\n```\n\n### 依赖外部 crate\n\n```toml\n# add-one/Cargo.toml\n[dependencies]\nrand = \"0.5.5\"\n```\n\n## 使用 cargo install 从 Crates.io 安装二进制文件\n\n`cargo install` 的二进制文件都安装到 Rust 安装根目录的 `bin` 文件夹中。\n如果你使用 `rustup.rs` 安装的 Rust 且没有自定义任何配置，这将是`$HOME/.cargo/bin`\n\n```sh\ncargo install ripgrep\n```\n"}]}},"page":"/[...param]","query":{"param":["basic-concept","lib"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"库/包/模块"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>