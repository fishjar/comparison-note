<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>生命周期/作用域</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>生命周期/作用域</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="rust" autoComplete="off"/>rust</label></div></div></div></div><div class="card-group"></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"lifetime","fullPath":"/basic-concept/lifetime","asPath":"/basic-concept/lifetime","id":"%2Fbasic-concept%2Flifetime","parent":{"name":"basic-concept","fullPath":"/basic-concept","asPath":"/basic-concept","id":"%2Fbasic-concept","readme":{"title":"基础概念","fullPath":"/basic-concept/README.md"}},"readme":{"title":"生命周期/作用域","fullPath":"/basic-concept/lifetime/README.md"},"cards":[{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/basic-concept/lifetime/rust.md"}],"nodes":[]},"content":"","cards":[{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/basic-concept/lifetime/rust.md","content":"Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域。\n\n## 悬垂引用\n\n```rust\n{\n    let r;\n    {\n        let x = 5;\n        r = \u0026x;\n    }\n    println!(\"r: {}\", r);\n}\n```\n\n```rust\n// 错误\n// 因为 Rust 并不知道将要返回的引用是指向 x 或 y。\nfn longest(x: \u0026str, y: \u0026str) -\u003e \u0026str {\n    if x.len() \u003e y.len() {\n        x\n    } else {\n        y\n    }\n}\nfn main() {\n    // string1 直到外部作用域结束都是有效的\n    let string1 = String::from(\"long string is long\");\n    {\n        // string2 则在内部作用域中是有效的\n        let string2 = String::from(\"xyz\");\n        let result = longest(string1.as_str(), string2.as_str());\n        println!(\"The longest string is {}\", result);\n    }\n}\n```\n\n## 生命周期标注语法\n\n- 生命周期标注并不改变任何引用的生命周期的长短。\n- 生命周期参数名称必须以撇号（`'`）开头，其名称通常全是小写，类似于泛型其名称非常短。\n\n```rust\n\u0026i32        // 引用\n\u0026'a i32     // 带有显式生命周期的引用\n\u0026'a mut i32 // 带有显式生命周期的可变引用\n```\n\n```rust\n// 函数定义指定了签名中所有的引用必须有相同的生命周期 'a\n// 我们并没有改变任何传入值或返回值的生命周期，\n// 而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。\n// longest 函数并不需要知道 x 和 y 具体会存在多久，\n// 而只需要知道有某个可以被 'a 替代的作用域将会满足这个签名。\n// 被 'a 所替代的具体生命周期是 x 的作用域与 y 的作用域相重叠的那一部分。\n// 换一种说法就是泛型生命周期 'a 的具体生命周期等同于 x 和 y 的生命周期中较小的那一个。\n// 所以返回的引用值就能保证在 x 和 y 中较短的那个生命周期结束之前保持有效。\nfn longest\u003c'a\u003e(x: \u0026'a str, y: \u0026'a str) -\u003e \u0026'a str {\n    if x.len() \u003e y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n\n```rust\n// 错误\n// longest 函数返回的引用的生命周期应该与传入参数的生命周期中较短那个保持一致。\n// 因此，借用检查器不允许示例中的代码，因为它可能会存在无效的引用。\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    // result 有可能引用 string2， 但string2已经离开作用域\n    println!(\"The longest string is {}\", result);\n}\n```\n\n```rust\n// 为参数 x 和返回值指定了生命周期参数 'a，不过没有为参数 y 指定，\n// 因为 y 的生命周期与参数 x 和返回值的生命周期没有任何关系。\nfn longest\u003c'a\u003e(x: \u0026'a str, y: \u0026str) -\u003e \u0026'a str {\n    x\n}\n```\n\n## 结构体定义中的生命周期标注\n\n```rust\n// 定义包含引用的结构体，需要为结构体定义中的每一个引用添加生命周期标注。\nstruct ImportantExcerpt\u003c'a\u003e {\n    part: \u0026'a str,\n}\nfn main() {\n    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n    let first_sentence = novel.split('.')\n        .next()\n        .expect(\"Could not find a '.'\");\n    let i = ImportantExcerpt { part: first_sentence };\n}\n```\n\n## 生命周期省略（Lifetime Elision）\n\n编译器采用三条规则来判断引用何时不需要明确的标注。\n第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。\n如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。\n这些规则适用于 fn 定义，以及 impl 块。\n\n- 第一条规则是每一个是引用的参数都有它自己的生命周期参数。\n- 第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数\n- 第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是`\u0026self` 或 `\u0026mut self`，说明是个对象的方法(method), 那么所有输出生命周期参数被赋予 `self` 的生命周期。\n\n```rust\nfn first_word(s: \u0026str) -\u003e \u0026str {\n    let bytes = s.as_bytes();\n    for (i, \u0026item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return \u0026s[0..i];\n        }\n    }\n    \u0026s[..]\n}\n// 完整函数签名如下\nfn first_word\u003c'a\u003e(s: \u0026'a str) -\u003e \u0026'a str {}\n```\n\n```rust\nfn first_word(s: \u0026str) -\u003e \u0026str {}\nfn first_word\u003c'a\u003e(s: \u0026'a str) -\u003e \u0026str {} // 第一条规则\nfn first_word\u003c'a\u003e(s: \u0026'a str) -\u003e \u0026'a str {} // 第二条规则\n\nfn longest(x: \u0026str, y: \u0026str) -\u003e \u0026str {}\nfn longest\u003c'a, 'b\u003e(x: \u0026'a str, y: \u0026'b str) -\u003e \u0026str {} // 第一条规则\n```\n\n## 方法定义中的生命周期标注\n\n```rust\n// impl 和类型名称之后的生命周期参数是必要的\nimpl\u003c'a\u003e ImportantExcerpt\u003c'a\u003e {\n    // 依据第一条规则，可以省略 self 引用的生命周期\n    fn level(\u0026self) -\u003e i32 {\n        3\n    }\n}\n```\n\n```rust\nimpl\u003c'a\u003e ImportantExcerpt\u003c'a\u003e {\n    // 第一条生命周期省略规则并给予 \u0026self 和 announcement 他们各自的生命周期。\n    // 因为其中一个参数是 \u0026self，返回值类型被赋予了 \u0026self 的生命周期\n    fn announce_and_return_part(\u0026self, announcement: \u0026str) -\u003e \u0026str {\n        println!(\"Attention please: {}\", announcement);\n        self.part\n    }\n}\n```\n\n## 静态生命周期\n\n`'static`，其生命周期能够存活于整个程序期间。\n\n```rust\nlet s: \u0026'static str = \"I have a static lifetime.\";\n```\n\n## 结合泛型类型参数、trait bounds 和生命周期\n\n```rust\nuse std::fmt::Display;\nfn longest_with_an_announcement\u003c'a, T\u003e(x: \u0026'a str, y: \u0026'a str, ann: T) -\u003e \u0026'a str\n    where T: Display\n{\n    println!(\"Announcement! {}\", ann);\n    if x.len() \u003e y.len() {\n        x\n    } else {\n        y\n    }\n}\n```"}]}},"page":"/[...param]","query":{"param":["basic-concept","lifetime"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"生命周期/作用域"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>