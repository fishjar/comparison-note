<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>宏</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>宏</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="c" autoComplete="off"/>c</label><label class="btn btn-secondary"><input type="checkbox" value="rust" autoComplete="off"/>rust</label></div></div></div></div><div class="card-group"></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"macro","fullPath":"/basic-concept/macro","asPath":"/basic-concept/macro","id":"%2Fbasic-concept%2Fmacro","parent":{"name":"basic-concept","fullPath":"/basic-concept","asPath":"/basic-concept","id":"%2Fbasic-concept","readme":{"title":"基础概念","fullPath":"/basic-concept/README.md"}},"readme":{"title":"宏","fullPath":"/basic-concept/macro/README.md"},"cards":[{"name":"c.md","baseName":"c","extName":".md","fullPath":"/basic-concept/macro/c.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/basic-concept/macro/rust.md"}],"nodes":[]},"content":"","cards":[{"name":"c.md","baseName":"c","extName":".md","fullPath":"/basic-concept/macro/c.md","content":"```c++\n// 将源码里面的MAX，全部替换成100\n#define MAX 100\n\n\n#define HELLO \"Hello, world\"\n// 相当于 printf(\"%s\", \"Hello, world\");\nprintf(\"%s\", HELLO);\n\n\n// 多重替换\n#define TWO 2\n#define FOUR TWO*TWO\n\n\n// 如果宏出现在字符串里面（即出现在双引号中），或者是其他标识符的一部分，就会失效，并不会发生替换\n#define TWO 2\nprintf(\"TWO\\n\"); // 输出 TWO\nconst TWOs = 22;\nprintf(\"%d\\n\", TWOs); // 输出 22\n```\n\n## 带参数的宏\n\n```c++\n// 宏SQUARE可以接受一个参数X，替换成X*X\n#define SQUARE(X) X*X\n// 替换成 z = 2*2;\nz = SQUARE(2);\n\n\n// 输出19\n// 3 + 4*3 + 4\nprintf(\"%d\\n\", SQUARE(3 + 4));\n\n\n// 尽量多使用圆括号，避免意外\n#define SQUARE(X) ((X) * (X))\n\n\n// 一些例子\n#define getchar() getc(stdin)\n#define MAX(x, y) ((x)\u003e(y)?(x):(y))\n#define IS_EVEN(n) ((n)%2==0)\n\n// 嵌套 (一元二次方程组求解的宏)\n// 由于存在正负两个解，所以宏QUAD先替换成另外两个宏QUADP和QUADM，后者再各自替换成一个解\n#define QUADP(a, b, c) ((-(b) + sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))\n#define QUADM(a, b, c) ((-(b) - sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))\n#define QUAD(a, b, c) QUADP(a, b, c), QUADM(a, b, c)\n```\n\n## `#`运算符，`##`运算符\n\n```c++\n// 希望替换后的值为字符串\n#define STR(x) #x\n// 等同于 printf(\"%s\\n\", \"3.14159\");\nprintf(\"%s\\n\", STR(3.14159));\n\n#define XNAME(n) \"x\"#n\n// 输出 x4\nprintf(\"%s\\n\", XNAME(4));\n\n\n// 参数需要跟其他标识符连在一起，组成一个新的标识符\n// 批量生成变量名和标识符\n#define MK_ID(n) i##n\nint MK_ID(1), MK_ID(2), MK_ID(3);\n// 替换成\nint i1, i2, i3;\n```\n\n## 不定参数的宏\n\n```c++\n#define X(a, b, ...) (10*(a) + 20*(b)), __VA_ARGS__\nX(5, 4, 3.14, \"Hi!\", 12)\n// 替换成\n(10*(5) + 20*(4)), 3.14, \"Hi!\", 12\n```\n\n## `#undef`\n\n有时候想重新定义一个宏，但不确定是否以前定义过，就可以先用`#undef` 取消\n\n```c++\n#define LIMIT 400\n#undef LIMIT // 取消已经使用#define定义的宏\n```\n\n```sh\n# 在命令行取消宏的定义，相当于#undef\ngcc -ULIMIT foo.c\n```\n\n## 预定义宏\n\n- `__DATE__`：编译日期，格式为“Mmm dd yyyy”的字符串（比如 Nov 23 2021）。\n- `__TIME__`：编译时间，格式为“hh:mm:ss”。\n- `__FILE__`：当前文件名。\n- `__LINE__`：当前行号。\n- `__func__`：当前正在执行的函数名。该预定义宏必须在函数作用域使用。\n- `__STDC__`：如果被设为 1，表示当前编译器遵循 C 标准。\n- `__STDC_HOSTED__`：如果被设为 1，表示当前编译器可以提供完整的标准库；否则被设为 0（嵌入式系统的标准库常常是不完整的）。\n- `__STDC_VERSION__`：编译所使用的 C 语言版本，是一个格式为 yyyymmL 的长整数，C99 版本为“199901L”，C11 版本为“201112L”，C17 版本为“201710L”。\n\n```c++\n#include \u003cstdio.h\u003e\n\nint main(void) {\n  printf(\"This function: %s\\n\", __func__);\n  printf(\"This file: %s\\n\", __FILE__);\n  printf(\"This line: %d\\n\", __LINE__);\n  printf(\"Compiled on: %s %s\\n\", __DATE__, __TIME__);\n  printf(\"C Version: %ld\\n\", __STDC_VERSION__);\n}\n\n/* 输出如下\n\nThis function: main\nThis file: test.c\nThis line: 7\nCompiled on: Mar 29 2021 19:19:37\nC Version: 201710\n\n*/\n```\n\n```c++\n// 将下一行的行号重置为 300\n#line 300\n\n\n// `#error` 指令用于让预处理器抛出一个错误，终止编译。\n#if __STDC_VERSION__ != 201112L\n  #error Not C11\n#endif\n\n\n// 使用 C99 标准\n#pragma c9x on\n```\n"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/basic-concept/macro/rust.md","content":"从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的 元编程（metaprogramming）\n\n声明（Declarative）宏\n\n- 使用 `macro_rules!` 的 声明（Declarative）宏，\n  - 其核心概念是，声明宏允许我们编写一些类似 Rust match 表达式的代码。\n\n过程宏（procedural macros）\n\n- 过程宏接收 Rust 代码作为输入，在这些代码上进行操作，然后产生另一些代码作为输出，而非像声明式宏那样匹配对应模式然后以另一部分代码替换当前代码。\n\n  - 自定义 `#[derive]` 宏在结构体和枚举上指定通过 derive 属性添加的代码\n  - 类属性（Attribute-like）宏定义可用于任意项的自定义属性\n  - 类函数宏看起来像函数不过作用于作为参数传递的 token\n\n函数与宏的区别\n\n- 一个函数标签必须声明函数参数个数和类型。\n  - 相比之下，宏能够接受不同数量的参数：用一个参数调用 `println!(\"hello\")` 或用两个参数调用 `println!(\"hello {}\", name)` 。\n- 宏可以在编译器翻译代码前展开，例如，宏可以在一个给定类型上实现 trait 。\n  - 而函数则不行，因为函数是在运行时被调用\n- 在一个文件里调用宏 之前 必须定义它，或将其引入作用域，\n  - 而函数则可以在任何地方定义和调用。\n\n## 声明（Declarative）宏\n\n```rust\n// vec! 宏定义的简化版本\n// #[macro_export] 标注说明，只要将定义了宏的 crate 引入作用域，宏就应当是可用的。\n// 如果没有该标注，这个宏就不能被引入作用域。\n#[macro_export]\nmacro_rules! vec {\n    // 此处有一个单边模式 ( $( $x:expr ),* )\n    // 一对括号()包含了整个模式\n    // $() 捕获了符合括号内模式的值以用于替换后的代码。\n    // $x:expr 匹配 Rust 的任意表达式，并将该表达式记作 $x\n    // 紧随逗号之后的 * 说明该模式匹配零个或更多个 * 之前的任何模式\n    // vec![1, 2, 3]; 调用宏时，$x 模式与三个表达式 1、2 和 3 进行了三次匹配\n    // 对于每个（在 =\u003e 前面）匹配模式中的 $() 的部分，\n    // 生成零个或更多个（在 =\u003e 后面）位于 $()* 内的 temp_vec.push() ，\n    // 生成的个数取决于该模式被匹配的次数。\n    ( $( $x:expr ), * ) =\u003e {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x); // $x 由每个与之相匹配的表达式所替换。\n            )*\n            temp_vec\n        }\n    };\n}\nlet v: Vec\u003cu32\u003e = vec![1, 2, 3];\n\n// 调用该宏时，替换该宏调用所生成的代码会是下面这样：\nlet mut temp_vec = Vec::new();\ntemp_vec.push(1);\ntemp_vec.push(2);\ntemp_vec.push(3);\ntemp_vec\n```\n\n### 指示符\n\n全部指示符：\n\n- `block`\n- `expr` 用于表达式\n- `ident` 用于变量名或函数名\n- `item`\n- `pat` (模式 pattern)\n- `path`\n- `stmt` (语句 statement)\n- `tt` (标记树 token tree)\n- `ty` (类型 type)\n\n```rust\nmacro_rules! create_function {\n    // 此宏接受一个 `ident` 指示符表示的参数，并创建一个名为 `$func_name` 的函数。\n    // `ident` 指示符用于变量名或函数名\n    ($func_name:ident) =\u003e (\n        fn $func_name() {\n            // `stringify!` 宏把 `ident` 转换成字符串。\n            println!(\"You called {:?}()\",\n                     stringify!($func_name))\n        }\n    )\n}\n\n// 借助上述宏来创建名为 `foo` 和 `bar` 的函数。\ncreate_function!(foo);\ncreate_function!(bar);\n\nmacro_rules! print_result {\n    // 此宏接受一个 `expr` 类型的表达式，并将它作为字符串，连同其结果一起\n    // 打印出来。\n    // `expr` 指示符表示表达式。\n    ($expression:expr) =\u003e (\n        // `stringify!` 把表达式*原样*转换成一个字符串。\n        println!(\"{:?} = {:?}\",\n                 stringify!($expression),\n                 $expression)\n    )\n}\n\nfn main() {\n    foo();\n    bar();\n\n    print_result!(1u32 + 1);\n\n    // 回想一下，代码块也是表达式！\n    print_result!({\n        let x = 1u32;\n\n        x * x + 2 * x - 1\n    });\n}\n```\n\n### 重载\n\n```rust\n// 根据你调用它的方式，`test!` 将以不同的方式来比较 `$left` 和 `$right`。\nmacro_rules! test {\n    // 参数不需要使用逗号隔开。\n    // 参数可以任意组合！\n    ($left:expr; and $right:expr) =\u003e (\n        println!(\"{:?} and {:?} is {:?}\",\n                 stringify!($left),\n                 stringify!($right),\n                 $left \u0026\u0026 $right)\n    );\n    // ^ 每个分支都必须以分号结束。\n    ($left:expr; or $right:expr) =\u003e (\n        println!(\"{:?} or {:?} is {:?}\",\n                 stringify!($left),\n                 stringify!($right),\n                 $left || $right)\n    );\n}\n\nfn main() {\n    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);\n    test!(true; or false);\n}\n```\n\n### 重复\n\n宏在参数列表中可以使用 `+` 来表示一个参数可能出现一次或多次，使用 `*` 来表示该 参数可能出现零次或多次。\n\n```rust\n// `min!` 将求出任意数量的参数的最小值。\nmacro_rules! find_min {\n    // 基本情形：\n    ($x:expr) =\u003e ($x);\n    // `$x` 后面跟着至少一个 `$y,`\n    ($x:expr, $($y:expr),+) =\u003e (\n        // 对 `$x` 后面的 `$y` 们调用 `find_min!`\n        std::cmp::min($x, find_min!($($y),+))\n    )\n}\n\nfn main() {\n    println!(\"{}\", find_min!(1u32));\n    println!(\"{}\", find_min!(1u32 + 2 , 2u32));\n    println!(\"{}\", find_min!(5u32, 2u32 * 3, 4u32));\n}\n```\n\n### DRY (不写重复代码)\n\n```rust\nuse std::ops::{Add, Mul, Sub};\n\nmacro_rules! assert_equal_len {\n    // `tt`（token tree，标记树）指示符表示运算符和标记。\n    ($a:ident, $b: ident, $func:ident, $op:tt) =\u003e (\n        assert!($a.len() == $b.len(),\n                \"{:?}: dimension mismatch: {:?} {:?} {:?}\",\n                stringify!($func),\n                ($a.len(),),\n                stringify!($op),\n                ($b.len(),));\n    )\n}\n\nmacro_rules! op {\n    ($func:ident, $bound:ident, $op:tt, $method:ident) =\u003e (\n        fn $func\u003cT: $bound\u003cT, Output=T\u003e + Copy\u003e(xs: \u0026mut Vec\u003cT\u003e, ys: \u0026Vec\u003cT\u003e) {\n            assert_equal_len!(xs, ys, $func, $op);\n\n            for (x, y) in xs.iter_mut().zip(ys.iter()) {\n                *x = $bound::$method(*x, *y);\n                // *x = x.$method(*y);\n            }\n        }\n    )\n}\n\n// 实现 `add_assign`、`mul_assign` 和 `sub_assign` 等函数。\nop!(add_assign, Add, +=, add);\nop!(mul_assign, Mul, *=, mul);\nop!(sub_assign, Sub, -=, sub);\n\nmod test {\n    use std::iter;\n    macro_rules! test {\n        ($func: ident, $x:expr, $y:expr, $z:expr) =\u003e {\n            #[test]\n            fn $func() {\n                for size in 0usize..10 {\n                    let mut x: Vec\u003c_\u003e = iter::repeat($x).take(size).collect();\n                    let y: Vec\u003c_\u003e = iter::repeat($y).take(size).collect();\n                    let z: Vec\u003c_\u003e = iter::repeat($z).take(size).collect();\n\n                    super::$func(\u0026mut x, \u0026y);\n\n                    assert_eq!(x, z);\n                }\n            }\n        }\n    }\n\n    // 测试 `add_assign`、`mul_assign` 和 `sub_assign`\n    test!(add_assign, 1u32, 2u32, 3u32);\n    test!(mul_assign, 2u32, 3u32, 6u32);\n    test!(sub_assign, 3u32, 2u32, 1u32);\n}\n```\n\n### DSL（领域专用语言）\n\n```rust\nmacro_rules! calculate {\n    (eval $e:expr) =\u003e {{\n        {\n            let val: usize = $e; // 强制类型为整型\n            println!(\"{} = {}\", stringify!{$e}, val);\n        }\n    }};\n}\n\nfn main() {\n    calculate! {\n        eval 1 + 2 // 看到了吧，`eval` 可并不是 Rust 的关键字！\n    }\n\n    calculate! {\n        eval (1 + 2) * (3 / 4)\n    }\n}\n```\n\n### 可变参数接口\n\n```rust\nmacro_rules! calculate {\n    // 单个 `eval` 的模式\n    (eval $e:expr) =\u003e {{\n        {\n            let val: usize = $e; // Force types to be integers\n            println!(\"{} = {}\", stringify!{$e}, val);\n        }\n    }};\n\n    // 递归地拆解多重的 `eval`\n    (eval $e:expr, $(eval $es:expr),+) =\u003e {{\n        calculate! { eval $e }\n        calculate! { $(eval $es),+ }\n    }};\n}\n\nfn main() {\n    calculate! { // 妈妈快看，可变参数的 `calculate!`！\n        eval 1 + 2,\n        eval 3 + 4,\n        eval (2 * 3) + 1\n    }\n}\n```\n\n## 过程宏（procedural macros）\n\n- 创建过程宏时，其定义必须驻留在它们自己的具有特殊 crate 类型的 crate 中。\n- 可以在同一个 crate 中拥有多种过程宏。\n\n```rust\n// src/lib.rs\nuse proc_macro;\n// some_attribute 是一个使用特定宏的占位符。\n#[some_attribute]\npub fn some_name(input: TokenStream) -\u003e TokenStream {\n}\n```\n\n### 自定义 derive 宏\n\n#### 未使用宏的代码\n\n```rust\n// src/lib.rs\npub trait HelloMacro {\n    fn hello_macro();\n}\n```\n\n```rust\n// src/main.rs\nuse hello_macro::HelloMacro;\nstruct Pancakes;\nimpl HelloMacro for Pancakes {\n    fn hello_macro() {\n        println!(\"Hello, Macro! My name is Pancakes!\");\n    }\n}\nfn main() {\n    Pancakes::hello_macro();\n}\n```\n\n#### 使用宏\n\n```sh\n# 目录结构\n├── hello_macro\n│   ├── Cargo.lock\n│   ├── Cargo.toml\n│   ├── hello_macro_derive\n│   │   ├── Cargo.toml\n│   │   └── src\n│   │       └── lib.rs\n│   └── src\n│       └── lib.rs\n├── pancakes\n│   ├── Cargo.lock\n│   ├── Cargo.toml\n│   └── src\n│       └── main.rs\n```\n\n```rust\n// hello_macro/src/lib.rs\npub trait HelloMacro {\n    fn hello_macro();\n}\n```\n\n```toml\n# hello_macro/hello_macro_derive/Cargo.toml\n[lib]\nproc-macro = true\n\n[dependencies]\nsyn = \"1.0\"\nquote = \"1.0\"\n```\n\n```rust\n// hello_macro/hello_macro_derive/src/lib.rs\nextern crate proc_macro;\n\nuse crate::proc_macro::TokenStream;\nuse quote::quote; // quote 则将 syn 解析的数据结构转换回 Rust 代码。\nuse syn; // syn crate 将字符串中的 Rust 代码解析成为一个可以操作的数据结构。\n\n// hello_macro_derive 函数负责解析 TokenStream，\n// impl_hello_macro 函数则负责转换语法树：\n// 当用户在一个类型上指定 #[derive(HelloMacro)] 时，\n// hello_macro_derive 函数将会被调用。\n#[proc_macro_derive(HelloMacro)]\npub fn hello_macro_derive(input: TokenStream) -\u003e TokenStream {\n    // 将 Rust 代码解析为语法树以便进行操作\n    let ast = syn::parse(input).unwrap();\n\n    // 构建 trait 实现\n    impl_hello_macro(\u0026ast)\n}\n\n// 使用解析过的 Rust 代码实现 HelloMacro trait\nfn impl_hello_macro(ast: \u0026syn::DeriveInput) -\u003e TokenStream {\n    let name = \u0026ast.ident;\n    // quote! 宏让我们可以编写希望返回的 Rust 代码。\n    let gen = quote! {\n        // 模板机制：写 #name ，然后 quote! 会以名为 name 的变量值来替换它。\n        impl HelloMacro for #name {\n            fn hello_macro() {\n                // stringify! 为 Rust 内置宏。\n                // 其接收一个 Rust 表达式，如 1 + 2 ， 然后在编译时将表达式转换为一个字符串常量\n                println!(\"Hello, Macro! My name is {}\", stringify!(#name));\n            }\n        }\n    };\n    // quote! 宏执行的直接结果并不是编译器所期望的并需要转换为 TokenStream。\n    // 为此需要调用 into 方法\n    gen.into()\n}\n```\n\n```toml\n# pancakes/Cargo.toml\n[dependencies]\nhello_macro = { path = \"../hello_macro\" }\nhello_macro_derive = { path = \"../hello_macro/hello_macro_derive\" }\n```\n\n```rust\n// pancakes/src/main.rs\nuse hello_macro::HelloMacro;\nuse hello_macro_derive::HelloMacro;\n\n#[derive(HelloMacro)]\nstruct Pancakes;\n\nfn main() {\n    Pancakes::hello_macro();\n}\n```\n\n```rust\n// 语法树 DeriveInput 结构体\nDeriveInput {\n    // --snip--\n    ident: Ident {\n        ident: \"Pancakes\",\n        span: #0 bytes(95..103)\n    },\n    data: Struct(\n        DataStruct {\n            struct_token: Struct,\n            fields: Unit,\n            semi_token: Some(\n                Semi\n            )\n        }\n    )\n}\n```\n\n### 类属性宏\n\n- 类属性宏与自定义派生宏相似，不同于为 derive 属性生成代码，它们允许你创建新的属性。\n- derive 只能用于结构体和枚举；属性还可以用于其它的项，比如函数。\n\n```rust\n// 使用例子\n#[route(GET, \"/\")]\nfn index() {}\n\n// 宏定义的函数签名看起来像这样：\n// 两个 TokenStream 类型的参数；\n// 第一个用于属性内容本身，也就是 GET, \"/\" 部分。\n// 第二个是属性所标记的项：在本例中，是 fn index() {} 和剩下的函数体。\n#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -\u003e TokenStream {}\n```\n\n### 类函数宏\n\n- 类函数宏定义看起来像函数调用的宏。\n- 类似于 `macro_rules!`，它们比函数更灵活；例如，可以接受未知数量的参数。\n\n```rust\n// 一个类函数宏例子\nlet sql = sql!(SELECT * FROM posts WHERE id=1);\n\n// sql! 宏应该被定义为如此：\n#[proc_macro]\npub fn sql(input: TokenStream) -\u003e TokenStream {}\n```\n"}]}},"page":"/[...param]","query":{"param":["basic-concept","macro"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"宏"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>