<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>内存管理</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>内存管理</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="c" autoComplete="off"/>c</label></div></div></div></div><div class="card-group"></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"memory","fullPath":"/basic-concept/memory","asPath":"/basic-concept/memory","id":"%2Fbasic-concept%2Fmemory","parent":{"name":"basic-concept","fullPath":"/basic-concept","asPath":"/basic-concept","id":"%2Fbasic-concept","readme":{"title":"基础概念","fullPath":"/basic-concept/README.md"}},"readme":{"title":"内存管理","fullPath":"/basic-concept/memory/README.md"},"cards":[{"name":"c.md","baseName":"c","extName":".md","fullPath":"/basic-concept/memory/c.md"}],"nodes":[]},"content":"","cards":[{"name":"c.md","baseName":"c","extName":".md","fullPath":"/basic-concept/memory/c.md","content":"C 语言的内存管理，分成两部分。\n\n- 一部分是系统管理的 (”栈“（stack）)\n- 另一部分是用户手动管理的 (”堆“（heap）)\n\n## `void` 指针\n\n```c++\nint x = 10;\nvoid* p = \u0026x; // 整数指针转为 void 指针\nint* q = p; // void 指针转为整数指针\n\nchar a = 'X';\nvoid* p = \u0026a;\nprintf(\"%c\\n\", *p); // 报错\n```\n\n## `malloc()`\n\n```c++\n// stdlib.h\nvoid* malloc(size_t size)\n```\n\n```c++\nint* p = malloc(sizeof(int));\nint* p = (int*) malloc(sizeof(int));\nint* p = (int*) malloc(sizeof(*p));\n\n*p = 12;\nprintf(\"%d\\n\", *p); // 12\n```\n\n`malloc()`分配内存有可能分配失败，这时返回常量 `NULL`。\n`Null` 的值为 0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针\n\n```c++\nint* p = malloc(sizeof(int));\n\nif (p == NULL) {\n  // 内存分配失败\n}\n\n// or\nif (!p) {\n  //...\n}\n```\n\n```c++\n// p是一个整数指针，指向一段可以放置10个整数的内存\nint* p = (int*) malloc(sizeof(int) * 10);\nfor (int i = 0; i \u003c 10; i++)\n  p[i] = i * 5;\n\n// 字符串初始化可以使用strcpy()函数\nchar* p = malloc(4);\nstrcpy(p, \"abc\");\n// or\np = \"abc\";\n```\n\n```c++\n// malloc()可以根据变量n的不同，动态为数组分配不同的大小\nint* p = (int*) malloc(n * sizeof(int));\n```\n\n## `free()`\n\n`free()`用于释放`malloc()`函数分配的内存\n\n```c++\n// stdlib.h\nvoid free(void* block)\n```\n\n```c++\nint* p = (int*) malloc(sizeof(int));\n*p = 12;\nfree(p);\n```\n\n## `calloc()`\n\n- `calloc()`接受两个参数，第一个参数是某种数据类型的值的数量，第二个是该数据类型的单位字节长度。\n- `calloc()`的返回值也是一个 `void` 指针。分配失败时，返回 `NULL`\n- `calloc()`会将所分配的内存全部初始化为 0。\n  - `malloc()`不会对内存进行初始化，如果想要初始化为 0，还要额外调用 `memset()`函数\n- `calloc()`分配的内存块，也要使用`free()`释放\n\n```c++\n// stdlib.h\nvoid* calloc(size_t n, size_t size);\n```\n\n```c++\nint* p = calloc(10, sizeof(int));\n\n// 等同于\nint* p = malloc(sizeof(int) * 10);\nmemset(p, 0, sizeof(int) * 10);\n```\n\n### `realloc()`\n\n- `realloc()`可能返回一个全新的地址，也可能返回跟原来一样的地址。\n- `realloc()`不会对内存块进行初始化\n- `block`：已经分配好的内存块指针（由`malloc()`或`calloc()`或`realloc()`产生）。\n- `size`：该内存块的新大小，单位为字节。\n\n```c++\n// stdlib.h\nvoid* realloc(void* block, size_t size)\n```\n\n```c++\nint* b;\n\nb = malloc(sizeof(int) * 10);\nb = realloc(b, sizeof(int) * 2000);\n```\n\n```c++\n// realloc()的第一个参数可以是 NULL，这时就相当于新建一个指针。\n// 如果realloc()的第二个参数是0，就会释放掉内存块。\nchar* p = realloc(NULL, 3490);\n// 等同于\nchar* p = malloc(3490);\n```\n\n## `restrict` 说明符\n\n使用 `restrict` 说明符，告诉编译器，该块内存区域只有当前指针一种访问方式\n\n```c++\nint* restrict p;\np = malloc(sizeof(int));\n\nint* q = p;\n*q = 0; // 未定义行为\n```\n\n## `memcpy()`\n\n- `dest` 是目标地址，`source` 是源地址\n- `dest` 和 `source` 都是 `void` 指针，表示这里不限制指针类型\n- 两者都有 `restrict` 关键字，表示这两个内存块不应该有互相重叠的区域\n- `memcpy()`的返回值是第一个参数，即目标地址的指针\n- `memcpy()`可以取代`strcpy()`进行字符串拷贝\n\n```c++\n// string.h\nvoid* memcpy(\n  void* restrict dest,\n  void* restrict source,\n  size_t n\n);\n```\n\n```c++\n// 字符串s所在的内存，被拷贝到字符数组t所在的内存\n#include \u003cstdio.h\u003e\n#include \u003cstring.h\u003e\nint main(void) {\n  char s[] = \"Goats!\";\n  char t[100];\n  memcpy(t, s, sizeof(s));  // 拷贝7个字节，包括终止符\n  printf(\"%s\\n\", t);  // \"Goats!\"\n  return 0;\n}\n```\n\n```c++\nchar* s = \"hello world\";\nsize_t len = strlen(s) + 1;\nchar *c = malloc(len);\nif (c) {\n  // strcpy() 的写法\n  strcpy(c, s);\n  // memcpy() 的写法\n  memcpy(c, s, len);\n}\n```\n\n```c++\n// 自定义一个复制内存的函数\nvoid* my_memcpy(void* dest, void* src, int byte_count) {\n  char* s = src;\n  char* d = dest;\n  while (byte_count--) {\n    // *d++ = *s++ 语句相当于先执行 *d = *s（源字节的值复制给目标字节），\n    // 然后各自移动到下一个字节。\n    *d++ = *s++;\n  }\n  return dest;\n}\n```\n\n## `memmove()`\n\n`memmove()`函数用于将一段内存数据复制到另一段内存。\n它跟 `memcpy()`的主要区别是，它允许目标区域与源区域有重叠。\n如果发生重叠，源区域的内容会被更改；如果没有重叠，它与 `memcpy()`行为相同。\n\n```c++\n// string.h\nvoid* memmove(\n  void* dest,\n  void* source,\n  size_t n\n);\n```\n\n```c++\n// 从数组成员a[1]开始的99个成员，都向前移动一个位置\nint a[100];\nmemmove(\u0026a[0], \u0026a[1], 99 * sizeof(int));\n\n// 从字符串x的5号位置开始的10个字节，就是“Sweet Home”，memmove()将其前移到0号位置\nchar x[] = \"Home Sweet Home\";\n// 输出 Sweet Home Home\nprintf(\"%s\\n\", (char *) memmove(x, \u0026x[5], 10));\n```\n\n## `memcmp()`\n\n```c++\n// string.h\nint memcmp(\n  const void* s1,\n  const void* s2,\n  size_t n\n);\n```\n\n```c++\nchar* s1 = \"abc\";\nchar* s2 = \"acd\";\nint r = memcmp(s1, s2, 3); // 小于 0\n```\n\n```c++\nchar s1[] = {'b', 'i', 'g', '\\0', 'c', 'a', 'r'};\nchar s2[] = {'b', 'i', 'g', '\\0', 'c', 'a', 't'};\n\nif (memcmp(s1, s2, 3) == 0) // true\nif (memcmp(s1, s2, 4) == 0) // true\nif (memcmp(s1, s2, 7) == 0) // false\n```\n"}]}},"page":"/[...param]","query":{"param":["basic-concept","memory"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"内存管理"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>