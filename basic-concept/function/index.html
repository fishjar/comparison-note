<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>函数和方法</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>函数和方法</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="c" autoComplete="off"/>c</label><label class="btn btn-secondary"><input type="checkbox" value="go" autoComplete="off"/>go</label><label class="btn btn-secondary"><input type="checkbox" value="rust" autoComplete="off"/>rust</label></div></div></div></div><div class="card-group"></div><div style="margin-top:12px" class="card"><div class="card-body"><h6>了解更多</h6><ul><li><a href="/comparison-note/basic-concept/function/closures/">闭包</a><span style="color:#666"> [go, rust]</span></li><li><a href="/comparison-note/basic-concept/function/recursion/">递归</a><span style="color:#666"> [go]</span></li><li><a href="/comparison-note/basic-concept/function/variadic/">变参函数</a><span style="color:#666"> [go]</span></li></ul></div></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"function","fullPath":"/basic-concept/function","asPath":"/basic-concept/function","id":"%2Fbasic-concept%2Ffunction","parent":{"name":"basic-concept","fullPath":"/basic-concept","asPath":"/basic-concept","id":"%2Fbasic-concept","readme":{"title":"基础概念","fullPath":"/basic-concept/README.md"}},"readme":{"title":"函数和方法","fullPath":"/basic-concept/function/README.md"},"cards":[{"name":"c.md","baseName":"c","extName":".md","fullPath":"/basic-concept/function/c.md"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/basic-concept/function/go.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/basic-concept/function/rust.md"}],"nodes":[{"name":"closures","fullPath":"/basic-concept/function/closures","asPath":"/basic-concept/function/closures","id":"%2Fbasic-concept%2Ffunction%2Fclosures","parent":{"name":"function","fullPath":"/basic-concept/function","asPath":"/basic-concept/function","id":"%2Fbasic-concept%2Ffunction","readme":{"title":"函数和方法","fullPath":"/basic-concept/function/README.md"}},"readme":{"title":"闭包","fullPath":"/basic-concept/function/closures/README.md"},"cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/basic-concept/function/closures/go.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/basic-concept/function/closures/rust.md"}],"nodes":[]},{"name":"recursion","fullPath":"/basic-concept/function/recursion","asPath":"/basic-concept/function/recursion","id":"%2Fbasic-concept%2Ffunction%2Frecursion","parent":{"name":"function","fullPath":"/basic-concept/function","asPath":"/basic-concept/function","id":"%2Fbasic-concept%2Ffunction","readme":{"title":"函数和方法","fullPath":"/basic-concept/function/README.md"}},"readme":{"title":"递归","fullPath":"/basic-concept/function/recursion/README.md"},"cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/basic-concept/function/recursion/go.md"}],"nodes":[]},{"name":"variadic","fullPath":"/basic-concept/function/variadic","asPath":"/basic-concept/function/variadic","id":"%2Fbasic-concept%2Ffunction%2Fvariadic","parent":{"name":"function","fullPath":"/basic-concept/function","asPath":"/basic-concept/function","id":"%2Fbasic-concept%2Ffunction","readme":{"title":"函数和方法","fullPath":"/basic-concept/function/README.md"}},"readme":{"title":"变参函数","fullPath":"/basic-concept/function/variadic/README.md"},"cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/basic-concept/function/variadic/go.md"}],"nodes":[]}]},"content":"","cards":[{"name":"c.md","baseName":"c","extName":".md","fullPath":"/basic-concept/function/c.md","content":"- 如果函数没有返回值，可以省略 return 语句，或者写成 return;\n- C 语言标准规定，函数只能声明在源码文件的顶层，不能声明在其他函数内部。\n- 函数可以调用自身，这就叫做递归（recursion）。\n- 函数不要返回内部变量的指针。\n\n```c++\nint plus_one(int n) {\n  return n + 1;\n}\n```\n\n```c++\nunsigned long Fibonacci(unsigned n) {\n  if (n \u003e 2)\n    return Fibonacci(n - 1) + Fibonacci(n - 2);\n  else\n    return 1;\n}\n```\n\n```c++\nvoid Swap(int* x, int* y) {\n  int temp;\n  temp = *x;\n  *x = *y;\n  *y = temp;\n}\n\nint a = 1;\nint b = 2;\nSwap(\u0026a, \u0026b);\n```\n\n## 函数原型\n\n```c++\n// 代码头部先给出了函数原型，所以可以正确编译\nint twice(int);\n\nint main(int num) {\n  return twice(num);\n}\n\nint twice(int num) {\n  return 2 * num;\n}\n```\n\n## `exit()`\n\n- 在 `main()`函数里面，`exit()`等价于使用 `return` 语句。\n- 其他函数使用 `exit()`，就是终止整个程序的运行，没有其他作用。\n\n```c++\n// 程序运行成功\n// 等同于 exit(0);\nexit(EXIT_SUCCESS);\n\n// 程序异常中止\n// 等同于 exit(1);\nexit(EXIT_FAILURE);\n```\n\nC 语言还提供了一个`atexit()`函数，用来登记`exit()`执行时额外执行的函数，用来做一些退出程序时的收尾工作。\n\n```c++\n// int atexit(void (*func)(void));\nvoid print(void) {\n  printf(\"something wrong!\\n\");\n}\n\natexit(print);\nexit(EXIT_FAILURE);\n```\n\n## 函数说明符\n\n### `extern` 说明符\n\n当前文件里面，需要给出外部函数的原型，并用 `extern` 说明该函数的定义来自其他文件。\n\n```c++\n// 函数foo()定义在其他文件，extern告诉编译器当前文件不包含该函数的定义\nextern int foo(int arg1, char arg2);\n\nint main(void) {\n  int a = foo(2, 3);\n  // ...\n  return 0;\n}\n```\n\n### `static` 说明符\n\n- `static` 用于函数内部声明变量时，表示该变量只需要初始化一次，不需要在每次调用时都进行初始化。\n- `static` 修饰的变量初始化时，只能赋值为常量，不能赋值为变量\n- 在块作用域中，`static` 声明的变量有默认值 0\n\n```c++\n#include \u003cstdio.h\u003e\n\nvoid counter(void) {\n  static int count = 1;  // 只初始化一次\n  printf(\"%d\\n\", count);\n  count++;\n}\n\nint main(void) {\n  counter();  // 1\n  counter();  // 2\n  counter();  // 3\n  counter();  // 4\n}\n```\n\n`static` 关键字表示该函数只能在当前文件里使用，如果没有这个关键字，其他文件也可以使用这个函数（通过声明函数原型）。\n\n```c++\nstatic int Twice(int num) {\n  int result = num * 2;\n  return(result);\n}\n```\n\n`static` 也可以用在参数里面，修饰参数数组。\n只是用来告诉编译器，该数组长度至少为 3，某些情况下可以加快程序运行速度。\n\n```c++\nint sum_array(int a[static 3], int n) {\n  // ...\n}\n```\n\n### `const` 说明符\n\n在指针参数前面加上 `const` 说明符，告诉编译器，函数内部不能修改该参数所指向的值。\n\n```c++\nvoid f(const int* p) {\n  *p = 0; // 该行报错\n}\n```\n\n但是上面这种写法，只限制修改 p 所指向的值，而 p 本身的地址是可以修改的。\n\n```c++\nvoid f(const int* p) {\n  int x = 13;\n  p = \u0026x; // 允许修改\n}\n```\n\n如果想同时限制修改 `p` 和 `*p`，需要使用两个 `const`\n\n```c++\nvoid f(const int* const p) {\n  // ...\n}\n```\n\n## 可变参数\n\n```c++\nint printf(const char* format, ...);\n```\n\n头文件 `stdarg.h` 定义了一些宏，可以操作可变参数。\n\n- （1）`va_list`：一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用。\n- （2）`va_start`：一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。\n- （3）`va_arg`：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。\n- （4）`va_end`：一个函数，用来清理可变参数对象。\n\n```c++\ndouble average(int i, ...) {\n  double total = 0;\n  va_list ap;\n  va_start(ap, i);\n  for (int j = 1; j \u003c= i; ++j) {\n    total += va_arg(ap, double);\n  }\n  va_end(ap);\n  return total / i;\n}\n```\n"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/basic-concept/function/go.md","content":"```go\npackage main\n\nimport \"fmt\"\n\nfunc add(x int, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.Println(add(42, 13))\n}\n```\n\n当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc add(x, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.Println(add(42, 13))\n}\n```\n\n函数可以返回任意数量的返回值。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n\nfunc main() {\n\ta, b := swap(\"hello\", \"world\")\n\tfmt.Println(a, b)\n}\n```\n\n### 命名返回值\n\nGo 的返回值可被命名，它们会被视作定义在函数顶部的变量。\n\n返回值的名称应当具有一定的意义，它可以作为文档使用。\n\n没有参数的 return 语句返回已命名的返回值。也就是 直接 返回。\n\n直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc split(sum int) (x, y int) {\n\tx = sum * 4 / 9\n\ty = sum - x\n\treturn\n}\n\nfunc main() {\n\tfmt.Println(split(17))\n}\n```\n"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/basic-concept/function/rust.md","content":"```rust\nfn main() {\n    let x = plus_one(5);\n\n    println!(\"The value of x is: {}\", x);\n}\n\nfn plus_one(x: i32) -\u003e i32 {\n    x + 1\n}\n```\n"}]}},"page":"/[...param]","query":{"param":["basic-concept","function"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"函数和方法"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>