<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>通道(channel)</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>通道(channel)</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="rust" autoComplete="off"/>rust</label></div></div></div></div><div class="card-group"></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"channel","fullPath":"/special/concurrent/channel","asPath":"/special/concurrent/channel","id":"%2Fspecial%2Fconcurrent%2Fchannel","parent":{"name":"concurrent","fullPath":"/special/concurrent","asPath":"/special/concurrent","id":"%2Fspecial%2Fconcurrent","readme":{"title":"并发编程","fullPath":"/special/concurrent/README.md"}},"readme":{"title":"通道(channel)","fullPath":"/special/concurrent/channel/README.md"},"cards":[{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/special/concurrent/channel/rust.md"}],"nodes":[]},"content":"","cards":[{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/special/concurrent/channel/rust.md","content":"编程中的通道有两部分组成，一个发送者（transmitter）和一个接收者（receiver）。\n\n```rust\nuse std::thread;\n// mpsc 是 多个生产者，单个消费者（multiple producer, single consumer）的缩写。\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        // send 方法返回一个 Result\u003cT, E\u003e 类型\n        tx.send(val).unwrap();\n\n        // 发送 val 后，所有权转移不能再使用\n        // println!(\"val is {}\", val);\n    });\n\n    // 通道的接收端有两个有用的方法：recv 和 try_recv。\n    // recv 会在一个 Result\u003cT, E\u003e 中返回它。\n    // try_recv 不会阻塞，相反它立刻返回一个 Result\u003cT, E\u003e\n    // Ok 值包含可用的信息，而 Err 值代表此时没有任何消息。\n    // 如果线程在等待消息过程中还有其他工作时使用 try_recv 很有用：\n    // 可以编写一个循环来频繁调用 try_recv，在有可用消息时进行处理，\n    // 其余时候则处理一会其他工作直到再次检查。\n    let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}\n```\n\n```rust\nuse std::thread;\nuse std::sync::mpsc;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    // 当通道被关闭时，迭代器也将结束。\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}\n```\n\n```rust\n// 通过克隆发送者来创建多个生产者\nlet (tx, rx) = mpsc::channel();\n\nlet tx1 = tx.clone();\nthread::spawn(move || {\n    let vals = vec![\n        String::from(\"hi\"),\n        String::from(\"from\"),\n        String::from(\"the\"),\n        String::from(\"thread\"),\n    ];\n\n    for val in vals {\n        tx1.send(val).unwrap();\n        thread::sleep(Duration::from_secs(1));\n    }\n});\n\nthread::spawn(move || {\n    let vals = vec![\n        String::from(\"more\"),\n        String::from(\"messages\"),\n        String::from(\"for\"),\n        String::from(\"you\"),\n    ];\n\n    for val in vals {\n        tx.send(val).unwrap();\n        thread::sleep(Duration::from_secs(1));\n    }\n});\n\nfor received in rx {\n    println!(\"Got: {}\", received);\n}\n```\n"}]}},"page":"/[...param]","query":{"param":["special","concurrent","channel"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"通道(channel)"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>