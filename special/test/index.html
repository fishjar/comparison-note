<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>自动化测试</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>自动化测试</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="go" autoComplete="off"/>go</label><label class="btn btn-secondary"><input type="checkbox" value="rust" autoComplete="off"/>rust</label></div></div></div></div><div class="card-group"></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"test","fullPath":"/special/test","asPath":"/special/test","id":"%2Fspecial%2Ftest","parent":{"name":"special","fullPath":"/special","asPath":"/special","id":"%2Fspecial","readme":{"title":"专题","fullPath":"/special/README.md"}},"readme":{"title":"自动化测试","fullPath":"/special/test/README.md"},"cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/special/test/go.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/special/test/rust.md"}],"nodes":[]},"content":"","cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/special/test/go.md","content":"## 一个例子\n\n```sh\nexample/\n   |--calc.go\n   |--calc_test.go\n```\n\n```go\n// calc.go\npackage main\n\nfunc Add(a int, b int) int {\n    return a + b\n}\n\nfunc Mul(a int, b int) int {\n    return a * b\n}\n```\n\n```go\n// calc_test.go\npackage main\n\nimport \"testing\"\n\nfunc TestAdd(t *testing.T) {\n\tif ans := Add(1, 2); ans != 3 {\n\t\tt.Errorf(\"1 + 2 expected be 3, but %d got\", ans)\n\t}\n\n\tif ans := Add(-10, -20); ans != -30 {\n\t\tt.Errorf(\"-10 + -20 expected be -30, but %d got\", ans)\n\t}\n}\n```\n\n```sh\n# 执行所有测试用例\n$ go test -v\n=== RUN   TestAdd\n--- PASS: TestAdd (0.00s)\n=== RUN   TestMul\n--- PASS: TestMul (0.00s)\nPASS\nok      example 0.007s\n\n# 只想运行其中的一个用例\n$ go test -run TestAdd -v\n=== RUN   TestAdd\n--- PASS: TestAdd (0.00s)\nPASS\nok      example 0.007s\n```\n\n## 单元测试\n\n运行 `go testing` 会扫描并编译运行工程目录下 `xxx_test.go` 代码文件中的 `TestXxx` 测试函数。\n\n- 测试代码文件名 `xxx_test.go`，必须遵守。\n- 测试函数签名 `TestXxx(t *testing.T)`，必须遵守。\n\n```sh\n# 当前目录（某目录）查找 xxx_test.go 测试代码\ngo test .\ngo test ./xxx/xxx\n\n# 当前目录（某目录）以及子目录下所的 xxx_test.go 测试代码\ngo test ./...\ngo test ./xxx/xxx/...\n\n# -v 参数，打开终端信息打印的开关。\n# 测试代码中的打印函数（t.Log、t.Skip、t.Error、t.Fatal）\n# fmt.Print 只会在任一测试函数为 FAIL 时，信息才会显示。\ngo test . -v\n\n# -run 用来指定执行某个 TestXXX 单元测试函数，支持使用正则表达式来匹配测试函数名称。\n# 像 TestMain、init() 这类框架性代码仍然会被执行，以确保环境正确。\ngo test -run ^TestXxx$\n```\n\n```go\n// youwu_test.go\n// 其实 t.Error 等同于 t.Log + t.Fail，当只标记错误不打印信息时，使用t.Fail。\n// 打印的函数 `t.Log`、`t.Error`、`t.Fatal` 都有对应的格式化形式 `t.Logf`、`t.Errorf`、`t.Fatalf`\npackage main_test\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\nfunc TestWorld(t *testing.T) {\n    t.Log(\"TestWorlds\")\n}\n\n// 初始化 init 方式\nfunc init() {\n    fmt.Println(\"hello, i'm \\\"init\\\".\")\n}\n\n// 使用 t 实例的 Cleanup 方法注册一个在单元测试程序退出前执行的函数。\n// 包级别：使用 TestMain 模式。\nfunc cleanuptest() {\n    fmt.Println(\"Cleanup.😀\")\n}\nfunc TestClean(t *testing.T) {\n    t.Cleanup(cleanuptest)\n    t.Log(\"testing done.\")\n}\n```\n\n```sh\n...\n=== RUN   TestReportError\n    youwu_test.go:42: report in: t.Error\n--- FAIL: TestReportError (0.00s)\n...\nexit status 1\nFAIL    hellotest       0.498s\n```\n\n```go\n// 跳出当前单元测试函数，状态为跳出（SKIP，不计为失败），执行下一个测试函数\nt.SkipNow()\n\n// .Log -\u003e t.SkipNow 打印并跳出当前单元测试函数\nt.Skip(\"信息\")\n\n// 标记当前单元测试函数状态为错误（FAILED），继续执行\nt.Fail()\n\n// 标记当前单元测试函数状态为错误（FAILED）并跳出，执行下一个测试函数\nt.FailNow()\n\n// t.Log(信息) -\u003e t.Fail()，该单元测试会继续执行\nt.Error(\"信息\")\n\n// t.Log(信息) -\u003e t.FailNow()，跳出该单元测试，执行下一个单元测试函数\nt.Fatal(\"信息\")\n```\n\n## 子测试\n\n```go\n// calc_test.go\n// t.Error/t.Errorf 遇错不停，还会继续执行其他的测试用例\n// t.Fatal/t.Fatalf 遇错即停\nfunc TestMul(t *testing.T) {\n\tt.Run(\"pos\", func(t *testing.T) {\n\t\tif Mul(2, 3) != 6 {\n\t\t\tt.Fatal(\"fail\")\n\t\t}\n\n\t})\n\tt.Run(\"neg\", func(t *testing.T) {\n\t\tif Mul(2, -3) != -6 {\n\t\t\tt.Fatal(\"fail\")\n\t\t}\n\t})\n}\n```\n\n对于多个子测试的场景，更推荐如下的写法(table-driven tests)：\n如果数据量较大，或是一些二进制数据，推荐使用相对路径从文件中读取。\n\n```go\n//  calc_test.go\nfunc TestMul(t *testing.T) {\n\tcases := []struct {\n\t\tName           string\n\t\tA, B, Expected int\n\t}{\n\t\t{\"pos\", 2, 3, 6},\n\t\t{\"neg\", 2, -3, -6},\n\t\t{\"zero\", 2, 0, 0},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.Name, func(t *testing.T) {\n\t\t\tif ans := Mul(c.A, c.B); ans != c.Expected {\n\t\t\t\tt.Fatalf(\"%d * %d expected %d, but %d got\",\n\t\t\t\t\tc.A, c.B, c.Expected, ans)\n\t\t\t}\n\t\t})\n\t}\n}\n```\n\n## 帮助函数\n\nGo 语言在 1.9 版本中引入了 `t.Helper()`，用于标注该函数是帮助函数，\n报错时将输出帮助函数调用者的信息，而不是帮助函数的内部信息。\n\n关于 helper 函数的 2 个建议：\n\n- 不要返回错误， 帮助函数内部直接使用 t.Error 或 t.Fatal 即可，\n- 调用 t.Helper() 让报错信息更准确，有助于定位。\n\n```go\n// calc_test.go\npackage main\n\nimport \"testing\"\n\ntype calcCase struct{ A, B, Expected int }\n\nfunc createMulTestCase(t *testing.T, c *calcCase) {\n\tt.Helper()\n\tif ans := Mul(c.A, c.B); ans != c.Expected {\n\t\tt.Fatalf(\"%d * %d expected %d, but %d got\",\n\t\t\tc.A, c.B, c.Expected, ans)\n\t}\n\n}\n\nfunc TestMul(t *testing.T) {\n\tcreateMulTestCase(t, \u0026calcCase{2, 3, 6})\n\tcreateMulTestCase(t, \u0026calcCase{2, -3, -6})\n\tcreateMulTestCase(t, \u0026calcCase{2, 0, 1}) // wrong case\n}\n```\n\n## TestMain 方式\n\n`TestMain` 是 `go testing` 测试框架的指定函数。\n用于控制整个测试过程，这个函数是包级别的。\n即一个包下，如果有多个 `xxx_test.go` 测试代码，只能在其中某个 `xxx_test.go` 中定义。\n\n```go\n// youwu_test.go\npackage main_test\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"testing\"\n)\n\nfunc TestHello(t *testing.T) {\n    t.Log(\"TestHello\")\n}\n\n// func TestWorld(t *testing.T) {\n//  t.Log(\"TestWorlds\")\n// }\n\nfunc cleanuptest() {\n    fmt.Println(\"Cleanup.😀\")\n}\nfunc TestClean(t *testing.T) {\n    t.Cleanup(cleanuptest)\n    t.Log(\"testing done.\")\n}\n\nfunc init() {\n    fmt.Println(\"hello, i'm \\\"init\\\".\")\n}\n\nfunc TestMain(m *testing.M) {\n    // 在开始运行单元测试代码之前\n    // 可以在此处添加环境初始化相关代码或者函数调用\n    fmt.Println(\"😀 开始所有测试前\")\n\n    retCode := m.Run()\n\n    // 在全部测试代码运行结束退出之前\n    // 可以在此处添加清理代码或函数调用\n    fmt.Println(\"😀 结束所有测试前\")\n\n    os.Exit(retCode)\n}\n```\n\n```sh\n~/Projects/go/examples/hellotest\n➜  go test -v\nhello, i'm \"init\".\n😀 开始所有测试前\n=== RUN   TestHello\n    youwu_test.go:10: TestHello\n--- PASS: TestHello (0.00s)\n=== RUN   TestClean\n    youwu_test.go:22: testing done.\nCleanup.😀\n--- PASS: TestClean (0.00s)\nPASS\n😀 结束所有测试前\nok      hellotest       0.369s\n```\n\n## benckmark 性能基准测试\n\n多次运行，并计算其平均执行时间从而评估其运行效率。\ngo 性能基准测试代码的函数命名：\n\n- `func BenchmarkXxx(*testing.T)`\n\n基准测试报告每一列值对应的含义如下：\n\n```go\ntype BenchmarkResult struct {\n    N         int           // 迭代次数\n    T         time.Duration // 基准测试花费的时间\n    Bytes     int64         // 一次迭代处理的字节数\n    MemAllocs uint64        // 总的分配内存的次数\n    MemBytes  uint64        // 总的分配内存的字节数\n}\n```\n\n```go\n// youwu_test.go\npackage main_test\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"os\"\n    \"testing\"\n)\n\nfunc TestHello(t *testing.T) {\n    t.Log(\"TestHello\")\n}\n\nfunc init() {\n    fmt.Println(\"hello, i'm \\\"init\\\".\")\n}\n\nfunc TestMain(m *testing.M) {\n    // 在开始运行单元测试代码之前\n    // 可以在此处添加环境初始化相关代码或者函数调用\n    fmt.Println(\"😀 开始所有测试前\")\n\n    retCode := m.Run()\n\n    // 在全部测试代码运行结束退出之前\n    // 可以在此处添加清理代码或函数调用\n    fmt.Println(\"😀 结束所有测试前\")\n\n    os.Exit(retCode)\n}\n\nfunc BenchmarkRandInt(b *testing.B) {\n    for i := 0; i \u003c b.N; i++ {\n        rand.Int()\n    }\n}\n```\n\n```sh\n~/Projects/go/examples/hellotest\n➜  go test -bench='Rand' -v .\nhello, i'm \"init\".\n😀 开始所有测试前\n=== RUN   TestHello\n    youwu_test.go:19: TestHello\n--- PASS: TestHello (0.00s)\ngoos: darwin\ngoarch: amd64\npkg: hellotest\ncpu: Intel(R) Core(TM) i5-7500 CPU @ 3.40GHz\nBenchmarkRandInt\nBenchmarkRandInt-4      70186930                16.21 ns/op\nPASS\n😀 结束所有测试前\nok      hellotest       1.476s\n```\n\n可以使用 b.ResetTimer() 先重置定时器\n\n```go\nfunc BenchmarkHello(b *testing.B) {\n    ... // 耗时操作\n    b.ResetTimer()\n    for i := 0; i \u003c b.N; i++ {\n        fmt.Sprintf(\"hello\")\n    }\n}\n```\n\n使用 RunParallel 测试并发性能\n\n```go\nfunc BenchmarkParallel(b *testing.B) {\n\ttempl := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\"))\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar buf bytes.Buffer\n\t\tfor pb.Next() {\n\t\t\t// 所有 goroutine 一起，循环一共执行 b.N 次\n\t\t\tbuf.Reset()\n\t\t\ttempl.Execute(\u0026buf, \"World\")\n\t\t}\n\t})\n}\n```\n"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/special/test/rust.md","content":"## 测试函数（测试用例）\n\n```rust\npub fn greeting(name: \u0026str) -\u003e String {\n    format!(\"Hello {}!\", name)\n}\n\npub struct Guess {\n    value: i32,\n}\n\nimpl Guess {\n    pub fn new(value: i32) -\u003e Guess {\n        if value \u003c 1 || value \u003e 100 {\n            panic!(\"Guess value must be between 1 and 100, got {}.\", value);\n        }\n\n        Guess { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // 基本测试\n    #[test]\n    fn it_works() {\n        assert_eq!(2 + 2, 4);\n    }\n\n    // 测试失败\n    #[test]\n    fn another() {\n        panic!(\"Make this test fail\");\n    }\n\n    // 自定义错误信息\n    // 任何在 assert! 的一个必需参数和 assert_eq! 和 assert_ne!\n    // 的两个必需参数之后指定的参数都会传递给 format! 宏\n    #[test]\n    fn greeting_contains_name() {\n        let result = greeting(\"Sunface\");\n        let target = \"孙飞\";\n        assert!(\n            result.contains(target),\n            \"你的问候中并没有包含目标姓名 {} ，你的问候是 {}\",\n            target,\n            result\n        );\n    }\n\n    // 测试panic\n    // 可以给 should_panic 属性增加一个可选的 expected 参数\n    #[test]\n    #[should_panic(expected = \"Guess value must be less than or equal to 100\")]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n\n    // 使用 Result\u003cT, E\u003e\n    // 不同于调用 assert_eq! 宏\n    // 测试通过时返回 Ok(())，在测试失败时返回带有 String 的 Err\n    #[test]\n    fn it_works() -\u003e Result\u003c(), String\u003e {\n        if 2 + 2 == 4 {\n            Ok(())\n        } else {\n            Err(String::from(\"two plus two does not equal four\"))\n        }\n    }\n\n    // 忽略测试\n    #[test]\n    #[ignore]\n    fn expensive_test() {\n        // 这里的代码需要几十秒甚至几分钟才能完成\n    }\n}\n```\n\n```rust\n// assert_eq! 和 assert_ne!。这两个宏分别比较两个值是相等还是不相等。\n// assert_eq! 和 assert_ne! 宏在底层分别使用了 == 和 !=。\n// 当断言失败时，这些宏会使用调试格式打印出其参数，\n// 这意味着被比较的值必需实现了 PartialEq 和 Debug trait\npub fn add_two(a: i32) -\u003e i32 {\n    a + 2\n}\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn it_adds_two() {\n        assert_eq!(4, add_two(2));\n    }\n    #[test]\n    fn it_adds_tree() {\n        assert_ne!(4, add_two(3));\n    }\n}\n```\n\n```sh\ncargo test\n\n# 使用 -- 分割命令行参数\n# 第一种是提供给 cargo test 命令本身的，这些参数在 -- 之前指定\n# 第二种是提供给编译后的可执行文件的，在 -- 之后指定\ncargo test --help\ncargo test -- --help\n\n# 显示测试函数中的 println!\ncargo test -- --show-output\n\n# 运行单个测试\ncargo test one_hundred\n\n# 通过名称来过滤测试（名称中带add）\ncargo test add\n\n# 运行被忽略的测试函数\ncargo test -- --ignored\n# 运行名称中带 run 且被忽略的测试函数\ncargo test run -- --ignored\n\n# 测试通过是打印内容会被截获忽略，失败才显示。\n# 截获输出的行为可以通过 --nocapture 参数来禁用\ncargo test -- --nocapture\n```\n\n## 单元测试、集成测试\n\n单元测试（unit tests）与 集成测试（integration tests）。\n\n- 单元测试倾向于更小而更集中，在隔离的环境中一次测试一个模块，或者是测试私有接口。\n  - 单元测试是跟正常的逻辑代码在同一个文件，因此必须对其进行特殊的标注，以便 Rust 可以识别。\n  - 规范是在每个文件中创建包含测试函数的 `tests` 模块，并使用 `cfg(test)` 标注模块\n- 而集成测试对于你的库来说则完全是外部的。\n  - 集成测试的目的是测试库的多个部分能否一起正常工作。\n  - 它们与其他外部代码一样，通过相同的方式使用你的代码，只测试公有接口而且每个测试都有可能会测试多个模块。\n    - 集成测试被放入单独的目录文件中\n    - 不需要创建测试模块及标注 `#[cfg(test)]`\n    - 只能调用通过 pub 定义的 API\n    - 一个标准的 Rust 项目，在它的根目录下会有一个 `tests` 目录，与 `src` 同级。\n    - 在集成测试的 tests 目录下，每一个文件都是一个独立的包\n\nRust 只支持对 lib 类型的包进行集成测试，对于二进制包例如 `src/main.rs` 是无能为力的。\n原因在于，我们无法在其它包中使用 use 引入二进制包，而只有 lib 类型的包才能被引入，例如 `src/lib.rs`\n\n集成测试示例：\n\n```rust\n// tests/integration_test.rs\nuse adder;\n\nmod common;\n\n#[test]\nfn it_adds_two() {\n    common::setup();\n    assert_eq!(4, adder::add_two(2));\n}\n```\n\n```rust\n// tests/common/mod.rs\n// 希望这个函数能被多个测试文件的测试函数调用\npub fn setup() {\n    // 编写特定库测试所需的代码\n}\n```\n\n单元测试的共享模块路径\n\n- `tests/common.rs`\n- `tests/common/mod.rs`\n  - 这样命名告诉 Rust 不要将 common 看作一个集成测试文件\n\n```sh\n# 运行某个特定集成测试文件中的所有测试\ncargo test --test integration_test\n```\n\n## 测试才引入的包\n\n`Cargo.toml`\n\n```toml\n# standard crate data is left out\n[dev-dependencies]\npretty_assertions = \"1\"\n```\n\n```rust\npub fn add(a: i32, b: i32) -\u003e i32 {\n    a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use pretty_assertions::assert_eq; // 该包仅能用于测试\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);\n    }\n}\n```\n\n## 断言\n\n- 所有模式下运行\n  - `assert!`\n  - `assert_eq!`\n  - `assert_ne!`\n- Debug 模式下运行\n  - `debug_assert!`\n  - `debug_assert_eq!`\n  - `debug_assert_ne!`\n\n## benckmark 基准测试\n\n性能测试包含了两种：压力测试和基准测试\n\n- 前者是针对接口 API，模拟大量用户去访问接口然后生成接口级别的性能数据；\n- 而后者是针对代码，可以用来测试某一段代码的运行速度，例如一个排序算法。\n\n官方提供的测试工具，目前最大的问题就是只能在非 stable 下使用，\n原因是需要在代码中引入 test 特性: `#![feature(test)]`\n\n需要先将当前仓库中的 Rust 版本从 stable 切换为 nightly:\n\n- 安装 nightly 版本：\\$ `rustup install nightly`\n- 使用以下命令确认版本已经安装成功 `rustup toolchain list`\n- 进入 adder 项目(之前为了学习测试专门创建的项目)的根目录，然后运行 `rustup override set nightly`，将该项目使用的 rust 设置为 nightly\n  - 使用 `rustup override set stable` 切换回 stable 版本\n\n```rust\n// src/lib.rs\n#![feature(test)]\n\nextern crate test;\n\npub fn add_two(a: i32) -\u003e i32 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use test::Bencher;\n\n    #[test]\n    fn it_works() {\n        assert_eq!(4, add_two(2));\n    }\n\n    #[bench]\n    fn bench_add_two(b: \u0026mut Bencher) {\n        b.iter(|| add_two(2));\n    }\n}\n```\n\n```rust\n#![feature(test)]\n\nextern crate test;\n\nfn fibonacci_u64(number: u64) -\u003e u64 {\n    let mut last: u64 = 1;\n    let mut current: u64 = 0;\n    let mut buffer: u64;\n    let mut position: u64 = 1;\n\n    return loop {\n        if position == number {\n            break current;\n        }\n\n        buffer = last;\n        last = current;\n        current = buffer + current;\n        position += 1;\n    };\n}\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use test::Bencher;\n\n    #[test]\n    fn it_works() {\n       assert_eq!(fibonacci_u64(1), 0);\n       assert_eq!(fibonacci_u64(2), 1);\n       assert_eq!(fibonacci_u64(12), 89);\n       assert_eq!(fibonacci_u64(30), 514229);\n    }\n\n    #[bench]\n    fn bench_u64(b: \u0026mut Bencher) {\n        b.iter(|| {\n            for i in 100..200 {\n                // LLVM认为fibonacci_u64函数调用的结果没有使用，\n                // 同时也认为该函数没有任何副作用(造成其它的影响，例如修改外部变量、访问网络等),\n                // 因此它有理由把这个函数调用优化掉！\n                // fibonacci_u64(i);\n                test::black_box(fibonacci_u64(test::black_box(i)));\n            }\n        });\n    }\n}\n```\n\n```sh\ncargo bench\n```\n"}]}},"page":"/[...param]","query":{"param":["special","test"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"自动化测试"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>