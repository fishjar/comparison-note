<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>泛型</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>泛型</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="go" autoComplete="off"/>go</label><label class="btn btn-secondary"><input type="checkbox" value="rust" autoComplete="off"/>rust</label></div></div></div></div><div class="card-group"></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"generics","fullPath":"/special/generics","asPath":"/special/generics","id":"%2Fspecial%2Fgenerics","parent":{"name":"special","fullPath":"/special","asPath":"/special","id":"%2Fspecial","readme":{"title":"专题","fullPath":"/special/README.md"}},"readme":{"title":"泛型","fullPath":"/special/generics/README.md"},"cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/special/generics/go.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/special/generics/rust.md"}],"nodes":[]},"content":"","cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/special/generics/go.md","content":"## 泛型类型\n\n```go\n// 无泛型\ntype IntSlice []int\nvar a IntSlice = []int{1, 2, 3}\n\n// 使用泛型\ntype Slice[T int|float32|float64 ] []T\n\n// 这里传入了类型实参int，泛型类型Slice[T]被实例化为具体的类型 Slice[int]\nvar a Slice[int] = []int{1, 2, 3}\nfmt.Printf(\"Type Name: %T\",a)  //输出：Type Name: Slice[int]\n\n// 传入类型实参float32, 将泛型类型Slice[T]实例化为具体的类型 Slice[string]\nvar b Slice[float32] = []float32{1.0, 2.0, 3.0}\nfmt.Printf(\"Type Name: %T\",b)  //输出：Type Name: Slice[float32]\n\n// MyMap类型定义了两个类型形参 KEY 和 VALUE。分别为两个形参指定了不同的类型约束\n// 这个泛型类型的名字叫： MyMap[KEY, VALUE]\ntype MyMap[KEY int | string, VALUE float32 | float64] map[KEY]VALUE\n\n// 用类型实参 string 和 flaot64 替换了类型形参 KEY 、 VALUE，泛型类型被实例化为具体的类型：MyMap[string, float64]\nvar a MyMap[string, float64] = map[string]float64{\n    \"jack_score\": 9.6,\n    \"bob_score\":  8.4,\n}\n\n// 一个泛型类型的结构体。可用 int 或 sring 类型实例化\ntype MyStruct[T int | string] struct {\n    Name string\n    Data T\n}\n\n// 一个泛型接口(关于泛型接口在后半部分会详细讲解）\ntype IPrintData[T int | float32 | string] interface {\n    Print(data T)\n}\n\n// 一个泛型通道，可用类型实参 int 或 string 实例化\ntype MyChan[T int | string] chan T\n\n// 类型形参的互相套用\ntype WowStruct[T int | float32, S []T] struct {\n    Data     S\n    MaxValue T\n    MinValue T\n}\n\n// 特殊的泛型类型\ntype Wow[T int | string] int\nvar a Wow[int] = 123     // 编译正确\nvar b Wow[string] = 123  // 编译正确\nvar c Wow[string] = \"hello\" // 编译错误，因为\"hello\"不能赋值给底层类型int\n```\n\n## 语法错误\n\n```go\n// 错误，类型形参不能单独使用\ntype CommonType[T int|string|float32] T\n\n// 匿名结构体不支持泛型\ntestCase := struct[T int|string] {\n        caseName string\n        got      T\n        want     T\n    }[int]{\n        caseName: \"test OK\",\n        got:      100,\n        want:     100,\n    }\n```\n\n当类型约束的一些写法会被编译器误认为是表达式时会报错。如下：\n\n```go\n//✗ 错误。T *int会被编译器误认为是表达式 T乘以int，而不是int指针\ntype NewType[T *int] []T\n// 上面代码再编译器眼中：它认为你要定义一个存放切片的数组，数组长度由 T 乘以 int 计算得到\ntype NewType [T * int][]T\n\n//✗ 错误。和上面一样，这里不光*被会认为是乘号，| 还会被认为是按位或操作\ntype NewType2[T *int|*float64] []T\n\n//✗ 错误\ntype NewType2 [T (int)] []T\n```\n\n为了避免这种误解，解决办法就是给类型约束包上 interface{} 或加上逗号消除歧义\n\n```go\ntype NewType[T interface{*int}] []T\ntype NewType2[T interface{*int|*float64}] []T\n\n// 如果类型约束中只有一个类型，可以添加个逗号消除歧义\ntype NewType3[T *int,] []T\n\n//✗ 错误。如果类型约束不止一个类型，加逗号是不行的\ntype NewType4[T *int|*float32,] []T\n```\n\n## 泛型类型的套娃\n\n```go\n// 先定义个泛型类型 Slice[T]\ntype Slice[T int|string|float32|float64] []T\n\n// ✗ 错误。泛型类型Slice[T]的类型约束中不包含uint, uint8\ntype UintSlice[T uint|uint8] Slice[T]\n\n// ✓ 正确。基于泛型类型Slice[T]定义了新的泛型类型 FloatSlice[T] 。FloatSlice[T]只接受float32和float64两种类型\ntype FloatSlice[T float32|float64] Slice[T]\n\n// ✓ 正确。基于泛型类型Slice[T]定义的新泛型类型 IntAndStringSlice[T]\ntype IntAndStringSlice[T int|string] Slice[T]\n// ✓ 正确 基于IntAndStringSlice[T]套娃定义出的新泛型类型\ntype IntSlice[T int] IntAndStringSlice[T]\n\n// 在map中套一个泛型类型Slice[T]\ntype WowMap[T int|string] map[string]Slice[T]\n// 在map中套Slice[T]的另一种写法\ntype WowMap2[T Slice[int] | Slice[string]] map[string]T\n```\n\n## 类型约束的两种选择\n\n```go\ntype WowStruct[T int|string] struct {\n    Name string\n    Data []T\n}\n\ntype WowStruct2[T []int|[]string] struct {\n    Name string\n    Data T\n}\n\ntype WowStruct3[T int | string] struct {\n    Data     []T\n    MaxValue T\n    MinValue T\n}\n```\n\n## 泛型 receiver\n\n```go\ntype MySlice[T int | float32] []T\n\nfunc (s MySlice[T]) Sum() T {\n    var sum T\n    for _, value := range s {\n        sum += value\n    }\n    return sum\n}\n\nvar s MySlice[int] = []int{1, 2, 3, 4}\nfmt.Println(s.Sum()) // 输出：10\n\nvar s2 MySlice[float32] = []float32{1.0, 2.0, 3.0, 4.0}\nfmt.Println(s2.Sum()) // 输出：10.0\n```\n\n### 基于泛型的队列\n\n```go\n// 这里类型约束使用了空接口，代表的意思是所有类型都可以用来实例化泛型类型 Queue[T]\ntype Queue[T interface{}] struct {\n    elements []T\n}\n\n// 将数据放入队列尾部\nfunc (q *Queue[T]) Put(value T) {\n    q.elements = append(q.elements, value)\n}\n\n// 从队列头部取出并从头部删除对应数据\nfunc (q *Queue[T]) Pop() (T, bool) {\n    var value T\n    if len(q.elements) == 0 {\n        return value, true\n    }\n\n    value = q.elements[0]\n    q.elements = q.elements[1:]\n    return value, len(q.elements) == 0\n}\n\n// 队列大小\nfunc (q Queue[T]) Size() int {\n    return len(q.elements)\n}\n\nvar q1 Queue[int]  // 可存放int类型数据的队列\nq1.Put(1)\nq1.Put(2)\nq1.Put(3)\nq1.Pop() // 1\nq1.Pop() // 2\nq1.Pop() // 3\n\nvar q2 Queue[string]  // 可存放string类型数据的队列\nq2.Put(\"A\")\nq2.Put(\"B\")\nq2.Put(\"C\")\nq2.Pop() // \"A\"\nq2.Pop() // \"B\"\nq2.Pop() // \"C\"\n\nvar q3 Queue[struct{Name string}]\nvar q4 Queue[[]int] // 可存放[]int切片的队列\nvar q5 Queue[chan int] // 可存放int通道的队列\nvar q6 Queue[io.Reader] // 可存放接口的队列\n// ......\n```\n\n## 泛型函数\n\n```go\n// 无泛型\nfunc Add(a int, b int) int {\n    return a + b\n}\n\n// 使用泛型\nfunc Add[T int | float32 | float64](a T, b T) T {\n    return a + b\n}\n\nAdd[int](1,2) // 传入类型实参int，计算结果为 3\nAdd[float32](1.0, 2.0) // 传入类型实参float32, 计算结果为 3.0\n\nAdd[string](\"hello\", \"world\") // 错误。因为泛型函数Add的类型约束中并不包含string\n\nAdd(1, 2)  // 1，2是int类型，编译器自动推导出类型实参T是int\nAdd(1.0, 2.0) // 1.0, 2.0 是浮点，编译请自动推导出类型实参T是float32\n```\n\n## 不支持的泛型情况\n\n### 匿名函数不支持泛型\n\n```go\n// 错误，匿名函数不能自己定义类型实参\nfnGeneric := func[T int | float32](a, b T) T {\n        return a + b\n}\n\nfmt.Println(fnGeneric(1, 2))\n```\n\n### Go 的方法并不支持泛型\n\n```go\ntype A struct {\n}\n\n// 错误，不支持泛型方法\nfunc (receiver A) Add[T int | float32 | float64](a T, b T) T {\n    return a + b\n}\n```\n\n通过 receiver 使用类型形参\n\n```go\ntype A[T int | float32 | float64] struct {}\n\n// 方法可以使用类型定义中的形参 T\nfunc (receiver A[T]) Add(a T, b T) T {\n    return a + b\n}\n\n// 用法：\nvar a A[int]\na.Add(1, 2)\n\nvar aa A[float32]\naa.Add(1.0, 2.0)\n```\n\n## 接口类型约束\n\n```go\n// 一个可以容纳所有int,uint以及浮点类型的泛型切片\ntype Slice[T int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64] []T\n\n// 将类型约束单独拿出来定义到接口中\ntype IntUintFloat interface {\n    int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64\n}\ntype Slice[T IntUintFloat] []T\n\n// 进行组合\ntype Int interface {\n    int | int8 | int16 | int32 | int64\n}\ntype Uint interface {\n    uint | uint8 | uint16 | uint32\n}\ntype Float interface {\n    float32 | float64\n}\ntype Slice[T Int | Uint | Float] []T  // 使用 '|' 将多个接口类型组合\n\n// 直接组合其他接口\ntype SliceElement interface {\n    Int | Uint | Float | string // 组合了三个接口类型并额外增加了一个 string 类型\n}\ntype Slice[T SliceElement] []T\n```\n\n## 指定底层类型\n\n```go\nvar s1 Slice[int] // 正确\n\ntype MyInt int\nvar s2 Slice[MyInt] // ✗ 错误。MyInt类型底层类型是int但并不是int类型，不符合 Slice[T] 的类型约束\n```\n\n在类型约束中使用类似 `~int` 这种写法的话，就代表着不光是 `int` ，\n所有以 `int` 为底层类型的类型也都可用于实例化\n\n```go\ntype Int interface {\n    ~int | ~int8 | ~int16 | ~int32 | ~int64\n}\n\ntype Uint interface {\n    ~uint | ~uint8 | ~uint16 | ~uint32\n}\ntype Float interface {\n    ~float32 | ~float64\n}\n\ntype Slice[T Int | Uint | Float] []T\n\nvar s Slice[int] // 正确\n\ntype MyInt int\nvar s2 Slice[MyInt]  // MyInt底层类型是int，所以可以用于实例化\n\ntype MyMyInt MyInt\nvar s3 Slice[MyMyInt]  // 正确。MyMyInt 虽然基于 MyInt ，但底层类型也是int，所以也能用于实例化\n\ntype MyFloat32 float32  // 正确\nvar s4 Slice[MyFloat32]\n```\n\n使用 `~` 时有一定的限制：\n\n- `~`后面的类型不能为接口\n- `~`后面的类型必须为基本类型\n\n```go\ntype MyInt int\n\ntype _ interface {\n    ~[]byte  // 正确\n    ~MyInt   // 错误，~后的类型必须为基本类型\n    ~error   // 错误，~后的类型不能为接口\n}\n```\n\n## 接口实现\n\n```go\ntype Uint interface {  // 类型集 Uint 是 ~uint 和 ~uint8 等类型的并集\n    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64\n}\n```\n\n```go\ntype AllInt interface {\n    ~int | ~int8 | ~int16 | ~int32 | ~int64 | ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint32\n}\n\ntype Uint interface {\n    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64\n}\n\ntype A interface { // 接口A代表的类型集是 AllInt 和 Uint 的交集\n    AllInt\n    Uint\n}\n\ntype B interface { // 接口B代表的类型集是 AllInt 和 ~int 的交集\n    AllInt\n    ~int\n}\n```\n\n## 空接口\n\n```go\ntype Slice[T any] []T // 代码等价于 type Slice[T interface{}] []T\n```\n\n## comparable(可比较) 和 可排序(ordered)\n\n```go\ntype MyMap[KEY comparable, VALUE any] map[KEY]VALUE // 正确\n```\n\n```go\n// Ordered 代表所有可比大小排序的类型\ntype Ordered interface {\n    Integer | Float | ~string\n}\n\ntype Integer interface {\n    Signed | Unsigned\n}\n\ntype Signed interface {\n    ~int | ~int8 | ~int16 | ~int32 | ~int64\n}\n\ntype Unsigned interface {\n    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr\n}\n\ntype Float interface {\n    ~float32 | ~float64\n}\n```\n\n## 接口的两种类型\n\n- 基本接口(Basic interface)\n  - 接口定义中如果只有方法\n- 通用（一般）接口(General interface)\n  - 接口内不光只有方法，还有类型\n  - 通用接口类型不能用来定义变量，只能用于泛型的类型约束中\n\n```go\ntype Uint interface { // 接口 Uint 中有类型，所以是通用接口\n    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64\n}\n\ntype ReadWriter interface {  // ReadWriter 接口既有方法也有类型，所以是通用接口\n    ~string | ~[]rune\n\n    Read(p []byte) (n int, err error)\n    Write(p []byte) (n int, err error)\n}\n```\n\n```go\ntype Uint interface {\n    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64\n}\n\nvar uintInf Uint // 错误。Uint是通用接口，只能用于类型约束，不得用于变量定义\n```\n"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/special/generics/rust.md","content":"```rust\n// 无泛型\nfn largest_i32(list: \u0026[i32]) -\u003e i32 {\n    let mut largest = list[0];\n    for \u0026item in list.iter() {\n        if item \u003e largest {\n            largest = item;\n        }\n    }\n    largest\n}\n\nfn largest_char(list: \u0026[char]) -\u003e char {\n    let mut largest = list[0];\n    for \u0026item in list.iter() {\n        if item \u003e largest {\n            largest = item;\n        }\n    }\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n    let result = largest_i32(\u0026number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n    let result = largest_char(\u0026char_list);\n    println!(\"The largest char is {}\", result);\n}\n```\n\n```rust\n// 使用泛型\n// fn largest\u003cT\u003e(list: \u0026[T]) -\u003e T {\n//     let mut largest = list[0];\n//     for \u0026item in list.iter() {\n//         if item \u003e largest {\n//             largest = item;\n//         }\n//     }\n//     largest\n// }\nfn largest\u003cT: PartialOrd + Copy\u003e(list: \u0026[T]) -\u003e T {\n    let mut largest = list[0];\n    for \u0026item in list.iter() {\n        if item \u003e largest {\n            largest = item;\n        }\n    }\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n    let result = largest(\u0026number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n    let result = largest(\u0026char_list);\n    println!(\"The largest char is {}\", result);\n}\n```\n\n## 函数中的泛型\n\n```rust\nstruct SGen\u003cT\u003e(T); // 泛型类型 `SGen`。\n// 定义一个函数 `generic`，接受一个 `SGen\u003cT\u003e` 类型的参数 `_s`。\n// 因为 `SGen\u003cT\u003e` 之前有 `\u003cT\u003e`，所以这个函数是关于 `T` 的泛型函数。\nfn generic\u003cT\u003e(_s: SGen\u003cT\u003e) {}\nfn main() {\n    // 为 `generic()` 显式地指定类型参数 `char`。\n    generic::\u003cchar\u003e(SGen('a'));\n\n    // 为 `generic()` 隐式地指定类型参数 `char`。\n    generic(SGen('c'));\n}\n```\n\n## 结构体定义中的泛型\n\n```rust\nstruct Point\u003cT\u003e {\n    x: T,\n    y: T,\n}\nfn main() {\n    let integer = Point { x: 5, y: 10 };\n    let float = Point { x: 1.0, y: 4.0 };\n}\n```\n\n```rust\nstruct Point\u003cT, U\u003e {\n    x: T,\n    y: U,\n}\nfn main() {\n    let both_integer = Point { x: 5, y: 10 };\n    let both_float = Point { x: 1.0, y: 4.0 };\n    let integer_and_float = Point { x: 5, y: 4.0 };\n}\n```\n\n## 枚举定义中的泛型\n\n```rust\nenum Option\u003cT\u003e {\n    Some(T),\n    None,\n}\nenum Result\u003cT, E\u003e {\n    Ok(T),\n    Err(E),\n}\n```\n\n## 方法定义中的泛型\n\n```rust\nstruct Point\u003cT\u003e {\n    x: T,\n    y: T,\n}\n// 在 impl 之后声明泛型 T ，这样 Rust 就知道 Point 的尖括号中的类型是泛型而不是具体类型。\nimpl\u003cT\u003e Point\u003cT\u003e {\n    fn x(\u0026self) -\u003e \u0026T {\n        \u0026self.x\n    }\n}\n// 可以选择为 Point\u003cf32\u003e 实例实现方法，而不是为泛型 Point 实例。\n// 意味着 Point\u003cf32\u003e 类型会有一个方法 distance_from_origin，\n// 而其他 T 不是 f32 类型的 Point\u003cT\u003e 实例则没有定义此方法。\nimpl Point\u003cf32\u003e {\n    fn distance_from_origin(\u0026self) -\u003e f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\nfn main() {\n    let p = Point { x: 5, y: 10 };\n    println!(\"p.x = {}\", p.x());\n}\n```\n\n```rust\nstruct Point\u003cT, U\u003e {\n    x: T,\n    y: U,\n}\nimpl\u003cT, U\u003e Point\u003cT, U\u003e {\n    // 方法使用了与结构体定义中不同类型的泛型\n    fn mixup\u003cV, W\u003e(self, other: Point\u003cV, W\u003e) -\u003e Point\u003cT, W\u003e {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\nfn main() {\n    let p1 = Point { x: 5, y: 10.4 };\n    let p2 = Point { x: \"Hello\", y: 'c'};\n    let p3 = p1.mixup(p2);\n    println!(\"p3.x = {}, p3.y = {}\", p3.x, p3.y);\n}\n```\n"}]}},"page":"/[...param]","query":{"param":["special","generics"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"泛型"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>