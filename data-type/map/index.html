<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>哈希表/字典</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>哈希表/字典</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="dart" autoComplete="off"/>dart</label><label class="btn btn-secondary"><input type="checkbox" value="go" autoComplete="off"/>go</label><label class="btn btn-secondary"><input type="checkbox" value="js" autoComplete="off"/>js</label><label class="btn btn-secondary"><input type="checkbox" value="python" autoComplete="off"/>python</label><label class="btn btn-secondary"><input type="checkbox" value="rust" autoComplete="off"/>rust</label></div></div></div></div><div class="card-group"></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"map","fullPath":"/data-type/map","asPath":"/data-type/map","id":"%2Fdata-type%2Fmap","parent":{"name":"data-type","fullPath":"/data-type","asPath":"/data-type","id":"%2Fdata-type","readme":{"title":"数据类型","fullPath":"/data-type/README.md"}},"readme":{"title":"哈希表/字典","fullPath":"/data-type/map/README.md"},"cards":[{"name":"dart.md","baseName":"dart","extName":".md","fullPath":"/data-type/map/dart.md"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/map/go.md"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/data-type/map/js.md"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/data-type/map/python.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/data-type/map/rust.md"}],"nodes":[]},"content":"","cards":[{"name":"dart.md","baseName":"dart","extName":".md","fullPath":"/data-type/map/dart.md","content":"```dart\nvar gifts = {\n  'first' : 'partridge',\n  'second': 'turtledoves',\n  'fifth' : 'golden rings'\n};\n\nvar gifts = new Map();\ngifts['first'] = 'partridge';\ngifts['second'] = 'turtledoves';\ngifts['fifth'] = 'golden rings';\n\nvar gifts = {'first': 'partridge'};\ngifts['fourth'] = 'calling birds';\n\nfinal constantMap = const {\n  2: 'helium',\n  10: 'neon',\n  18: 'argon',\n};\n\nvar pages = \u003cString, String\u003e{\n  'index.html': 'Homepage',\n  'robots.txt': 'Hints for web robots',\n  'humans.txt': 'We are people, not machines'\n};\n```\n\n## 从 map 中删除 key 和 value\n\n```dart\n// 使用中括号来访问或者设置 map 中的数据，\n// 使用 remove() 函数来从 map 中删除 key 和 value。\nvar nobleGases = {54: 'xenon'};\n// Retrieve a value with a key.\nassert(nobleGases[54] == 'xenon');\n// Check whether a map contains a key.\nassert(nobleGases.containsKey(54));\n// Remove a key and its value.\nnobleGases.remove(54);\nassert(!nobleGases.containsKey(54));\n```\n\n## Maps(字典)遍历，获取 map 的所有 key 和 value\n\n```dart\n// 使用 .length 来获取 map 中键值对的数目\nvar gifts = {'first': 'partridge'};\ngifts['fourth'] = 'calling birds';\nassert(gifts.length == 2);\n\nvar hawaiianBeaches = {\n  'Oahu'      : ['Waikiki', 'Kailua', 'Waimanalo'],\n  'Big Island': ['Wailea Bay', 'Pololu Beach'],\n  'Kauai'     : ['Hanalei', 'Poipu']\n};\n\n// Get all the keys as an unordered collection\n// (an Iterable).\nvar keys = hawaiianBeaches.keys;\n\nassert(keys.length == 3);\nassert(new Set.from(keys).contains('Oahu'));\n\n// Get all the values as an unordered collection\n// (an Iterable of Lists).\nvar values = hawaiianBeaches.values;\nassert(values.length == 3);\nassert(values.any((v) =\u003e v.contains('Waikiki')));\n```\n\n## 判断 map 是否包含一个 key\n\n```dart\n// 由于 map 的 value 可以为 null，\n// 所有通过 key 来获取 value 并通过 判断 value 是否为 null 来判断 key 是否存在是 行不通的。\nvar hawaiianBeaches = {\n  'Oahu'      : ['Waikiki', 'Kailua', 'Waimanalo'],\n  'Big Island': ['Wailea Bay', 'Pololu Beach'],\n  'Kauai'     : ['Hanalei', 'Poipu']\n};\n\nassert(hawaiianBeaches.containsKey('Oahu'));\nassert(!hawaiianBeaches.containsKey('Florida'));\n```\n"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/map/go.md","content":"```go\nages := make(map[string]int)\nages[\"alice\"] = 31\nages[\"charlie\"] = 34\n// 或\nages := map[string]int{\n    \"alice\":   31,\n    \"charlie\": 34,\n}\n\n// 删除元素\ndelete(ages, \"alice\") // remove element ages[\"alice\"]\n\n// 不能对map的元素进行取址操作\n// 原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效\n_ = \u0026ages[\"bob\"] // compile error: cannot take address of map element\n\n// 向一个nil值的map存入元素将导致一个panic异常\nages[\"carol\"] = 21 // panic: assignment to entry in nil map\n\nage, ok := ages[\"bob\"]\nif !ok { /* \"bob\" is not a key in this map; age == 0. */ }\n\nif age, ok := ages[\"bob\"]; !ok { /* ... */ }\n```\n\n遍历 map\n\n```go\n// 迭代顺序是不确定\nfor name, age := range ages {\n    fmt.Printf(\"%s\\t%d\\n\", name, age)\n}\n\n// 排序遍历\nimport \"sort\"\n\nvar names []string\n// names := make([]string, 0, len(ages))\nfor name := range ages {\n    names = append(names, name)\n}\nsort.Strings(names)\nfor _, name := range names {\n    fmt.Printf(\"%s\\t%d\\n\", name, ages[name])\n}\n```\n\n映射将键映射到值。\n映射的零值为 nil 。nil 映射既没有键，也不能添加键。\n`make` 函数会返回给定类型的映射，并将其初始化备用。\n\nmap 类型可以写为 map[K]V，其中 K 和 V 分别对应 key 和 value。\n其中 K 对应的 key 必须是支持==比较运算符的数据类型，\n所以 map 可以通过测试 key 是否相等来判断是否已经存在。\n对于 V 对应的 value 数据类型则没有任何的限制。\n\n内置的`make`函数可以创建一个 map：\n也可以用`map`字面值的语法创建 map，同时还可以指定一些最初的`key/value`：\n\n```go\nages := map[string]int{\n  \"alice\":   31,\n  \"charlie\": 34,\n}\n// 这相当于\nages := make(map[string]int)\nages[\"alice\"] = 31\nages[\"charlie\"] = 34\n\n\n// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化\nvar numbers map[string]int\n// 另一种map的声明方式\nnumbers := make(map[string]int)\nnumbers[\"one\"] = 1  //赋值\nnumbers[\"ten\"] = 10 //赋值\nnumbers[\"three\"] = 3\n\n\npackage main\nimport \"fmt\"\ntype Vertex struct {\n  Lat, Long float64\n}\nvar m map[string]Vertex\nfunc main() {\n  m = make(map[string]Vertex)\n  m[\"Bell Labs\"] = Vertex{\n    40.68433, -74.39967,\n  }\n  fmt.Println(m[\"Bell Labs\"])\n}\n// {40.68433 -74.39967}\n\n\n// 映射的文法与结构体相似，不过必须有键名。\npackage main\nimport \"fmt\"\ntype Vertex struct {\n  Lat, Long float64\n}\nvar m = map[string]Vertex{\n  \"Bell Labs\": Vertex{\n    40.68433, -74.39967,\n  },\n  \"Google\": Vertex{\n    37.42202, -122.08408,\n  },\n}\nfunc main() {\n  fmt.Println(m)\n}\n\n\n// 若顶级类型只是一个类型名，你可以在文法的元素中省略它。\npackage main\nimport \"fmt\"\ntype Vertex struct {\n  Lat, Long float64\n}\nvar m = map[string]Vertex{\n  \"Bell Labs\": {40.68433, -74.39967},\n  \"Google\":    {37.42202, -122.08408},\n}\nfunc main() {\n  fmt.Println(m)\n}\n\n\n// 修改映射\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n  m := make(map[string]int)\n\n  m[\"Answer\"] = 42 // 在映射 m 中插入或修改元素：\n  fmt.Println(\"The value:\", m[\"Answer\"]) // 获取元素：\n\n  m[\"Answer\"] = 48\n  fmt.Println(\"The value:\", m[\"Answer\"])\n\n  delete(m, \"Answer\") // 删除元素：\n  fmt.Println(\"The value:\", m[\"Answer\"])\n\n  // 通过双赋值检测某个键是否存在：\n  // 若 key 在 m 中，ok 为 true ；否则，ok 为 false。\n  // 若 key 不在映射中，那么 elem 是该映射元素类型的零值。\n  // 同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。\n  v, ok := m[\"Answer\"]\n  fmt.Println(\"The value:\", v, \"Present?\", ok)\n}\n// The value: 42\n// The value: 48\n// The value: 0\n// The value: 0 Present? false\n```\n"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/data-type/map/js.md","content":"JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。\nWeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。\n\n- WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名。\n- WeakMap 的键名所指向的对象，不计入垃圾回收机制。\n\nMap 结构原生提供三个遍历器生成函数和一个遍历方法。\n\n- `keys()`：返回键名的遍历器。\n- `values()`：返回键值的遍历器。\n- `entries()`：返回所有成员的遍历器。\n- `forEach()`：遍历 Map 的所有成员。\n\n```js\nlet { keys, values, entries } = Object;\nlet obj = { a: 1, b: 2, c: 3 };\nfor (let key of keys(obj)) {\n  console.log(key); // 'a', 'b', 'c'\n}\nfor (let value of values(obj)) {\n  console.log(value); // 1, 2, 3\n}\nfor (let [key, value] of entries(obj)) {\n  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]\n}\n\nconst m = new Map();\nconst o = { p: \"Hello World\" };\nm.set(o, \"content\");\nm.get(o); // \"content\"\nm.has(o); // true\nm.delete(o); // true\nm.has(o); // false\n\nconst map = new Map([\n  [\"name\", \"张三\"],\n  [\"title\", \"Author\"],\n]);\nmap.size; // 2\nmap.has(\"name\"); // true\nmap.get(\"name\"); // \"张三\"\nmap.has(\"title\"); // true\nmap.get(\"title\"); // \"Author\"\n\nconst map = new Map();\nmap.set(\"foo\", true);\nmap.set(\"bar\", false);\nmap.size; // 2\n\nconst m = new Map();\nm.set(undefined, \"nah\");\nm.has(undefined); // true\nm.delete(undefined);\nm.has(undefined); // false\n\nlet map = new Map();\nmap.set(\"foo\", true);\nmap.set(\"bar\", false);\nmap.size; // 2\nmap.clear();\nmap.size; // 0\n\nconst map = new Map([\n  [\"F\", \"no\"],\n  [\"T\", \"yes\"],\n]);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n// \"F\"\n// \"T\"\n\nfor (let value of map.values()) {\n  console.log(value);\n}\n// \"no\"\n// \"yes\"\n\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 或者\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\nconst someVariable = 2;\nconst someDict = { [someVariable + 1]: \"three\" };\n// three\nconsole.log(someDict[3]);\n```\n\n## 从 map 中删除 key 和 value\n\n```js\nconst m = new Map();\nm.set(undefined, \"nah\");\nm.has(undefined); // true\nm.delete(undefined);\nm.has(undefined); // false\n\nvar obj = Object.defineProperties(\n  {},\n  {\n    p1: { value: 1, configurable: true },\n    p2: { value: 2, configurable: false },\n  }\n);\ndelete obj.p1; // true\ndelete obj.p2; // false\nobj.p1; // undefined\nobj.p2; // 2\n```\n\n## Maps(字典)遍历，获取 map 的所有 key 和 value\n\n```js\n// for...in循环\n// 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。\n// 它不仅遍历对象自身的属性，还遍历继承的属性。\nvar obj = { a: 1, b: 2, c: 3 };\nfor (var i in obj) {\n  console.log(\"键名：\", i);\n  console.log(\"键值：\", obj[i]);\n}\n\n// 获取 map 中键值对的数目\nObject.keys(obj).length;\nObject.values(obj);\nObject.entries(obj);\n\nvar engines = new Set([\"Gecko\", \"Trident\", \"Webkit\", \"Webkit\"]);\nfor (var e of engines) {\n  console.log(e);\n}\n\nvar es6 = new Map();\nes6.set(\"edition\", 6);\nes6.set(\"committee\", \"TC39\");\nes6.set(\"standard\", \"ECMA-262\");\nfor (var [name, value] of es6) {\n  console.log(name + \": \" + value);\n}\n\nconst someList = [6, 3, 5];\n// 0 6\n// 1 3\n// 2 5\nsomeList.forEach((element, index) =\u003e {\n  console.log(`${index} ${element}`);\n});\n\nconst list1 = [1, 3, 5];\nconst list2 = [2, 4, 6];\n// [[1, 2], [3, 4], [5, 6]]\nconst zippedList = list1.map((x, y) =\u003e {\n  return [x, list2[y]];\n});\nzippedList.forEach((element) =\u003e {\n  console.log(`${element[0]} ${element[1]}`);\n});\n```\n\n```js\n// in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。\nvar obj = { p: 1 };\n\"p\" in obj; // true\n\"toString\" in obj; // true\n\nconst m = new Map();\nm.set(\"edition\", 6);\nm.set(262, \"standard\");\nm.set(undefined, \"nah\");\nm.has(\"edition\"); // true\nm.has(\"years\"); // false\nm.has(262); // true\nm.has(undefined); // true\n```\n"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/data-type/map/python.md","content":"```sh\n\u003e\u003e\u003e tel = {'jack': 4098, 'sape': 4139}\n\u003e\u003e\u003e tel['guido'] = 4127\n\u003e\u003e\u003e tel\n{'jack': 4098, 'sape': 4139, 'guido': 4127}\n\u003e\u003e\u003e tel['jack']\n4098\n\u003e\u003e\u003e del tel['sape']\n\u003e\u003e\u003e tel['irv'] = 4127\n\u003e\u003e\u003e tel\n{'jack': 4098, 'guido': 4127, 'irv': 4127}\n\u003e\u003e\u003e list(tel)\n['jack', 'guido', 'irv']\n\u003e\u003e\u003e sorted(tel)\n['guido', 'irv', 'jack']\n\u003e\u003e\u003e 'guido' in tel\nTrue\n\u003e\u003e\u003e 'jack' not in tel\nFalse\n\n# dict() 构造函数可以直接从键值对序列里创建字典。\n\u003e\u003e\u003e dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\n\n# 字典推导式可以从任意的键值表达式中创建字典\n\u003e\u003e\u003e {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\n\n# 当关键字是简单字符串时，有时直接通过关键字参数来指定键值对更方便\n\u003e\u003e\u003e dict(sape=4139, guido=4127, jack=4098)\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\n\n\nsome_variable = 2\nsome_dict = {(some_variable + 1): \"three\"}\n# three\nprint(some_dict[3])\n```\n\n循环的技巧\n\n```python\nsome_list = [6, 3, 5]\n# 0 6\n# 1 3\n# 2 5\nfor i, item in enumerate(some_list):\n    print(f\"{i} {item}\")\n# If you're not using this in a for loop, use list()\n# list(enumerate(some_list)) # [(0, 6), (1, 3), (2, 5)]\n\n\nlist_1 = [1, 3, 5]\nlist_2 = [2, 4, 6]\n# 1 2\n# 3 4\n# 5 6\nfor x, y in zip(list_1, list_2):\n    print(f\"{x} {y}\")\n```\n\n```sh\n# 当在字典中循环时，用 items() 方法可将关键字和对应的值同时取出\n\u003e\u003e\u003e knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n\u003e\u003e\u003e for k, v in knights.items():\n...     print(k, v)\n...\ngallahad the pure\nrobin the brave\n\n# 当在序列中循环时，用 enumerate() 函数可以将索引位置和其对应的值同时取出\n\u003e\u003e\u003e for i, v in enumerate(['tic', 'tac', 'toe']):\n...     print(i, v)\n...\n0 tic\n1 tac\n2 toe\n\n# 当同时在两个或更多序列中循环时，可以用 zip() 函数将其内元素一一匹配。\n\u003e\u003e\u003e questions = ['name', 'quest', 'favorite color']\n\u003e\u003e\u003e answers = ['lancelot', 'the holy grail', 'blue']\n\u003e\u003e\u003e for q, a in zip(questions, answers):\n...     print('What is your {0}?  It is {1}.'.format(q, a))\n...\nWhat is your name?  It is lancelot.\nWhat is your quest?  It is the holy grail.\nWhat is your favorite color?  It is blue.\n\n# 当逆向循环一个序列时，先正向定位序列，然后调用 reversed() 函数\n\u003e\u003e\u003e for i in reversed(range(1, 10, 2)):\n...     print(i)\n...\n9\n7\n5\n3\n1\n\n# 用 sorted() 函数，它可以在不改动原序列的基础上返回一个新的排好序的序列\n\u003e\u003e\u003e basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n\u003e\u003e\u003e for f in sorted(set(basket)):\n...     print(f)\n...\napple\nbanana\norange\npear\n\n# 有时可能会想在循环时修改列表内容，一般来说改为创建一个新列表是比较简单且安全的\n\u003e\u003e\u003e import math\n\u003e\u003e\u003e raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n\u003e\u003e\u003e filtered_data = []\n\u003e\u003e\u003e for value in raw_data:\n...     if not math.isnan(value):\n...         filtered_data.append(value)\n...\n\u003e\u003e\u003e filtered_data\n[56.2, 51.7, 55.3, 52.5, 47.8]\n```\n"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/data-type/map/rust.md","content":"```rust\nuse std::collections::HashMap;\n\n// 新建一个哈希 map\nlet mut scores = HashMap::new();\n\n// 使用 insert 增加元素\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50);\n\n// 覆盖一个值\nscores.insert(String::from(\"Blue\"), 25);\n\n// 只在键没有对应值时插入\n// entry 函数的返回值是一个枚举，Entry，\n// 它代表了可能存在也可能不存在的值\n// or_insert 方法在键对应的值存在时就返回这个值的可变引用，\n// 如果不存在则将参数作为新值插入并返回新值的可变引用。\nscores.entry(String::from(\"Yellow\")).or_insert(50);\nscores.entry(String::from(\"Blue\")).or_insert(50);\n\n// 访问哈希 map 中的值\n// 因为 get 返回 Option\u003cV\u003e，所以结果被装进 Some；\n// 如果某个键在哈希 map 中没有对应的值，get 会返回 None\nlet team_name = String::from(\"Blue\");\nlet score = scores.get(\u0026team_name);\n\n// 遍历哈希 map\nfor (key, value) in \u0026scores {\n    println!(\"{}: {}\", key, value);\n}\n\n// 根据旧值更新一个值\nlet text = \"hello world wonderful world\";\nlet mut map = HashMap::new();\nfor word in text.split_whitespace() {\n    let count = map.entry(word).or_insert(0); // 没有key则插入，并初始化\n    *count += 1; // 更新\n}\nprintln!(\"{:?}\", map);\n\n// 用队伍列表和分数列表创建哈希 map\nlet teams  = vec![String::from(\"Blue\"), String::from(\"Yellow\")];\nlet initial_scores = vec![10, 50];\n// 这里 HashMap\u003c_, _\u003e 类型标注是必要的，\n// 因为 collect 有可能当成多种不同的数据结构\nlet scores: HashMap\u003c_, _\u003e = teams.iter().zip(initial_scores.iter()).collect();\n```\n"}]}},"page":"/[...param]","query":{"param":["data-type","map"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"哈希表/字典"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>