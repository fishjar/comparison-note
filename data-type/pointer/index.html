<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>指针</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>指针</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="c" autoComplete="off"/>c</label><label class="btn btn-secondary"><input type="checkbox" value="go" autoComplete="off"/>go</label><label class="btn btn-secondary"><input type="checkbox" value="rust" autoComplete="off"/>rust</label></div></div></div></div><div class="card-group"></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"pointer","fullPath":"/data-type/pointer","asPath":"/data-type/pointer","id":"%2Fdata-type%2Fpointer","parent":{"name":"data-type","fullPath":"/data-type","asPath":"/data-type","id":"%2Fdata-type","readme":{"title":"数据类型","fullPath":"/data-type/README.md"}},"readme":{"title":"指针","fullPath":"/data-type/pointer/README.md"},"cards":[{"name":"c.md","baseName":"c","extName":".md","fullPath":"/data-type/pointer/c.md"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/pointer/go.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/data-type/pointer/rust.md"}],"nodes":[]},"content":"","cards":[{"name":"c.md","baseName":"c","extName":".md","fullPath":"/data-type/pointer/c.md","content":"```c++\n// 星号*可以放在变量名与类型关键字之间的任何地方\nint* intPtr;\nint   *intPtr;\nint * intPtr;\nint*  intPtr;\n\n// 正确\nint * foo, * bar;\n\n// 错误\n// foo是整数指针变量，而bar是整数变量，即*只对第一个变量生效\nint* foo, bar;\n\n// 表示变量foo是一个指针，指向的还是一个指针，第二个指针指向的则是一个整数。\nint** foo;\n```\n\n## `*` 运算符\n\n```c++\nvoid increment(int* p) {\n  *p = *p + 1; // *p就表示指针p所指向的那个值\n}\n\nint x = 1;\nincrement(\u0026x);\nprintf(\"%d\\n\", x); // 2\n```\n\n## `\u0026` 运算符\n\n```c++\n// x是一个整数变量，\u0026x就是x的值所在的内存地址。\n// printf()的%p是内存地址的占位符，可以打印出内存地址\nint x = 1;\nprintf(\"x's address is %p\\n\", \u0026x); // x's address is 0x7ffdca476054\n```\n\n## 指针变量的初始化\n\n指针变量声明后，必须先让它指向一个分配好的地址，然后再进行读写，这叫做指针变量的初始化。\n\n```c++\nint* p;\n*p = 1; // 错误\n```\n\n```c++\nint* p;\nint i;\n\np = \u0026i;\n*p = 13;\n```\n\nNULL 在 C 语言中是一个常量，表示地址为 0 的内存空间，这个地址是无法使用的，读写该地址会报错。\n\n```c++\nint* p = NULL;\n```\n\n## 指针的运算\n\n### 指针与整数值的加减运算\n\n`j + 1`表示指针向内存地址的高位移动一个单位，而一个单位的`short`类型占据两个字节的宽度，所以相当于向高位移动两个字节\n\n```c++\nshort* j;\nj = (short*)0x1234;\nj = j + 1; // 0x1236\n```\n\n### 指针与指针的加法运算(非法)\n\n### 指针与指针的减法\n\n相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位。\n\n```c++\nshort* j1;\nshort* j2;\n\nj1 = (short*)0x1234;\nj2 = (short*)0x1236;\n\nptrdiff_t dist = j2 - j1;\nprintf(\"%d\\n\", dist); // 1\n```\n\n## 函数指针\n\n```c++\nvoid print(int a) {\n  printf(\"%d\\n\", a);\n}\nvoid (*print_ptr)(int) = \u0026print;\n\n(*print_ptr)(10);\n// 等同于\nprint(10);\n```\n\n- C 语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。\n  - 也就是说，`print` 和 `\u0026print` 是一回事\n- 因此，上面代码的 `print_ptr` 等同于 `print`\n\n```c++\nif (print == \u0026print) // true\n\nvoid (*print_ptr)(int) = \u0026print;\n// 或\nvoid (*print_ptr)(int) = print;\nif (print_ptr == print) // true\n\n// 函数compute()的第一个参数也是一个函数\nint compute(int (*myfunc)(int), int, int);\n```\n\n对于任意函数，都有五种调用函数的写法。\n\n```c++\n// 写法一\nprint(10)\n\n// 写法二\n(*print)(10)\n\n// 写法三\n(\u0026print)(10)\n\n// 写法四\n(*print_ptr)(10)\n\n// 写法五\nprint_ptr(10)\n```\n"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/pointer/go.md","content":"Go 拥有指针。指针保存了值的内存地址。\n类型 `*T` 是指向 T 类型值的指针。其零值为 `nil`。\n与 C 不同，Go 没有指针运算。\n\n- `\u0026` 操作符会生成一个指向其操作数的指针。\n- `*` 操作符表示指针指向的底层值。\n\n```go\n// 类型 *T 是指向 T 类型值的指针。其零值为 nil。\nvar p *int\n\n\npackage main\nimport \"fmt\"\nfunc main() {\n  i, j := 42, 2701\n\n  p := \u0026i         // 指向 i\n  fmt.Println(*p) // 通过指针读取 i 的值\n  *p = 21         // 通过指针设置 i 的值\n  fmt.Println(i)  // 查看 i 的值\n\n  p = \u0026j         // 指向 j\n  *p = *p / 37   // 通过指针对 j 进行除法运算\n  fmt.Println(j) // 查看 j 的值\n}\n// 42\n// 21\n// 73\n```\n"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/data-type/pointer/rust.md","content":"- 指针 （`pointer`）是一个包含内存地址的变量的通用概念。\n  - 这个地址引用，或 “指向”（points at）一些其他数据。\n- 智能指针（`smart pointers`）是一类数据结构，它们的表现类似指针，但是也拥有额外的元数据和功能。\n  - Rust 标准库中不同的智能指针提供了多于引用的额外功能。\n  - 一个例子便是 引用计数 （reference counting）智能指针类型，其允许数据有多个所有者。\n    - 引用计数智能指针记录总共有多少个所有者，并当没有任何所有者时负责清理数据。\n  - `String` 和 `Vec\u003cT\u003e` 这些类型都属于智能指针因为它们拥有一些数据并允许你修改它们\n  - 智能指针通常使用结构体实现。\n  - 智能指针区别于常规结构体的显著特性在于其实现了 `Deref` 和 `Drop trait`。\n    - `Deref trait` 允许智能指针结构体实例表现的像引用一样\n    - `Drop trait` 允许我们自定义当智能指针离开作用域时运行的代码\n  - 常用智能指针\n    - `Box\u003cT\u003e`，用于在堆上分配值\n    - `Rc\u003cT\u003e`，一个引用计数类型，其数据可以有多个所有者\n    - `Ref\u003cT\u003e` 和 `RefMut\u003cT\u003e`，通过 `RefCell\u003cT\u003e` 访问\n- 普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；\n  - 相反，在大部分情况下，智能指针 拥有 它们指向的数据。\n\n## 使用 `Box\u003cT\u003e` 指向堆上的数据\n\nbox 允许你将一个值放在堆上而不是栈上。\n留在栈上的则是指向堆数据的指针。\n\n- 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候\n- 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候\n- 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候\n\n```rust\nfn main() {\n    let x = 5;\n    let y = Box::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y); // 像引用一样使用 Box\u003cT\u003e\n}\n```\n\n```rust\n// 没有使用智能指针，编译错误\n// 编译器无法知道 List 占用内存大小\nenum List {\n    Cons(i32, List),\n    Nil,\n}\nuse crate::List::{Cons, Nil};\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}\n```\n\n```rust\n// 使用智能指针\nenum List {\n    Cons(i32, Box\u003cList\u003e),\n    Nil,\n}\nuse crate::List::{Cons, Nil};\nfn main() {\n    let list = Cons(1,\n        Box::new(Cons(2,\n            Box::new(Cons(3,\n                Box::new(Nil))))));\n}\n```\n\n## 自定义智能指针\n\n```rust\nuse std::ops::Deref;\n\nstruct MyBox\u003cT\u003e(T); // 元组结构体\nimpl\u003cT\u003e MyBox\u003cT\u003e {\n    fn new(x: T) -\u003e MyBox\u003cT\u003e {\n        MyBox(x)\n    }\n}\n// 实现 Deref trait 的 deref 方法\nimpl\u003cT\u003e Deref for MyBox\u003cT\u003e {\n    // 语法定义了用于此 trait 的关联类型。\n    type Target = T;\n    // 输入 *y 时，Rust 事实上在底层运行了如下代码\n    // *(y.deref())\n    // * 解引用的操作，且只会发生一次，不会对 * 操作符无限递归替换\n    fn deref(\u0026self) -\u003e \u0026T {\n        \u0026self.0\n    }\n}\n// 参数可以是 \u0026i32 或 \u0026MyBox\u003ci32\u003e\nfn use_deref(n: \u0026i32) -\u003e \u0026i32 {\n    n\n}\n\n// 参数可以是 \u0026str 或 \u0026String 或 \u0026MyBox\u003cString\u003e\nfn hello(name: \u0026str) {\n    println!(\"Hello, {}!\", name);\n}\n\nfn main() {\n    let x = 5;\n    let y = MyBox::new(x);\n    assert_eq!(5, x);\n\n    assert_eq!(5, *use_deref(\u0026x));\n    // 参数需要 \u0026i32 类型，传入 \u0026MyBox\u003ci32\u003e 会强制转换\n    assert_eq!(5, *use_deref(\u0026y));\n\n    let m = \u0026String::from(\"Rust\");\n    hello(\u0026m);\n\n    // 如果 Rust 没有解引用强制转换\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(\u0026(*m)[..]);\n\n    // 当所涉及到的类型定义了 `Deref trait`，\n    // Rust 会分析这些类型并使用任意多次 `Deref::deref` 调用以获得匹配参数的类型。\n    // 这里进行了两次转换\n    // \u0026MyBox\u003cString\u003e -\u003e \u0026String\n    // \u0026String -\u003e \u0026str\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(\u0026m);\n}\n```\n\n## 函数和方法的隐式解引用强制转换（deref coercions）\n\n- 解引用强制转换（deref coercions）是 Rust 在函数或方法传参上的一种便利。\n- 解引用强制转换只能工作在实现了 `Deref trait` 的类型上。\n- 解引用强制转换将一种类型（A）隐式转换为另外一种类型（B）的引用，\n  因为 A 类型实现了 Deref trait，\n  并且其关联类型是 B 类型。\n- 比如，解引用强制转换可以将 `\u0026String` 转换为 `\u0026str`，\n  因为类型 `String` 实现了 `Deref trait` 并且其关联类型是 `str`。\n- 当所涉及到的类型定义了 `Deref trait`，Rust 会分析这些类型并使用任意多次 `Deref::deref` 调用以获得匹配参数的类型。\n\nRust 在发现类型和 trait 实现满足三种情况时会进行解引用强制转换：\n\n- 当 `T: Deref\u003cTarget=U\u003e` 时从 `\u0026T` 到 `\u0026U`。\n- 当 `T: DerefMut\u003cTarget=U\u003e` 时从 `\u0026mut T` 到 `\u0026mut U`。\n- 当 `T: Deref\u003cTarget=U\u003e` 时从 `\u0026mut T` 到 `\u0026U`。\n\n```rust\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Deref for String {\n    type Target = str; // 关联类型是 `str`\n    #[inline]\n    fn deref(\u0026self) -\u003e \u0026str {\n        unsafe { str::from_utf8_unchecked(\u0026self.vec) }\n    }\n}\n```\n\n## 使用 Drop Trait 运行清理代码\n\n```rust\nstruct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(\u0026mut self) {\n        println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer { data: String::from(\"my stuff\") };\n    let d = CustomSmartPointer { data: String::from(\"other stuff\") };\n    println!(\"CustomSmartPointers created.\");\n}\n```\n\n```rust\nfn main() {\n    let c = CustomSmartPointer { data: String::from(\"some data\") };\n    println!(\"CustomSmartPointer created.\");\n    // 通过 std::mem::drop 提早丢弃值\n    drop(c);\n    println!(\"CustomSmartPointer dropped before the end of main.\");\n}\n```\n\n## `Rc\u003cT\u003e` 引用计数智能指针\n\n- Rust 有一个叫做 `Rc\u003cT\u003e` 的类型。其名称为 引用计数（reference counting）的缩写。\n- `Rc\u003cT\u003e` 只能用于单线程场景\n\n- 修改 `List` 的定义为使用 `Rc\u003cT\u003e` 代替 `Box\u003cT\u003e`\n- 每次调用 `Rc::clone`，`Rc\u003cList\u003e` 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。\n- 也可以调用 `a.clone()` 而不是 `Rc::clone(\u0026a)`\n- `Rc::clone` 的实现并不像大部分类型的 clone 实现那样对所有数据进行深拷贝。\n  `Rc::clone` 只会增加引用计数，这并不会花费多少时间。\n\n```rust\nenum List {\n    Cons(i32, Rc\u003cList\u003e),\n    Nil,\n}\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    // 调用 Rc::clone 函数并传递 a 中 Rc\u003cList\u003e 的引用作为参数。\n    let b = Cons(3, Rc::clone(\u0026a));\n    let c = Cons(4, Rc::clone(\u0026a));\n}\n```\n\n```rust\n// 打印出引用计数\n// count after creating a = 1\n// count after creating b = 2\n// count after creating c = 3\n// count after c goes out of scope = 2\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    println!(\"count after creating a = {}\", Rc::strong_count(\u0026a));\n    let b = Cons(3, Rc::clone(\u0026a));\n    println!(\"count after creating b = {}\", Rc::strong_count(\u0026a));\n    {\n        let c = Cons(4, Rc::clone(\u0026a));\n        println!(\"count after creating c = {}\", Rc::strong_count(\u0026a));\n    }\n    println!(\"count after c goes out of scope = {}\", Rc::strong_count(\u0026a));\n}\n```\n\n## `RefCell\u003cT\u003e` 和内部可变性模式\n\n- `RefCell\u003cT\u003e` 记录当前有多少个活动的 `Ref\u003cT\u003e` 和 `RefMut\u003cT\u003e` 智能指针。\n- 每次调用 `borrow`，`RefCell\u003cT\u003e` 将活动的不可变借用计数加一。\n- 当 `Ref\u003cT\u003e` 值离开作用域时，不可变借用计数减一。\n- `RefCell\u003cT\u003e` 在任何时候只允许有多个不可变借用或一个可变借用。\n\n```rust\npub trait Messenger {\n    fn send(\u0026self, msg: \u0026str);\n}\npub struct LimitTracker\u003c'a, T: Messenger\u003e {\n    messenger: \u0026'a T,\n    value: usize,\n    max: usize,\n}\nimpl\u003c'a, T\u003e LimitTracker\u003c'a, T\u003e\n    where T: Messenger {\n    pub fn new(messenger: \u0026T, max: usize) -\u003e LimitTracker\u003cT\u003e {\n        LimitTracker {\n            messenger,\n            value: 0,\n            max,\n        }\n    }\n    pub fn set_value(\u0026mut self, value: usize) {\n        self.value = value;\n\n        let percentage_of_max = self.value as f64 / self.max as f64;\n\n        if percentage_of_max \u003e= 1.0 {\n            self.messenger.send(\"Error: You are over your quota!\");\n        } else if percentage_of_max \u003e= 0.9 {\n             self.messenger.send(\"Urgent warning: You've used up over 90% of your quota!\");\n        } else if percentage_of_max \u003e= 0.75 {\n            self.messenger.send(\"Warning: You've used up over 75% of your quota!\");\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::RefCell;\n    struct MockMessenger {\n        sent_messages: RefCell\u003cVec\u003cString\u003e\u003e,\n    }\n    impl MockMessenger {\n        fn new() -\u003e MockMessenger {\n            MockMessenger { sent_messages: RefCell::new(vec![]) }\n        }\n    }\n    impl Messenger for MockMessenger {\n        fn send(\u0026self, message: \u0026str) {\n            // borrow_mut 方法返回 RefMut\u003cT\u003e 类型的智能指针\n            self.sent_messages.borrow_mut().push(String::from(message));\n        }\n    }\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        let mock_messenger = MockMessenger::new();\n        let mut limit_tracker = LimitTracker::new(\u0026mock_messenger, 100);\n        limit_tracker.set_value(80);\n        // borrow 方法返回 Ref\u003cT\u003e 类型的智能指针\n        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);\n    }\n}\n```\n\n## 结合 `Rc\u003cT\u003e` 和 `RefCell\u003cT\u003e` 来拥有多个可变数据所有者\n\n```rust\n#[derive(Debug)]\nenum List {\n    Cons(Rc\u003cRefCell\u003ci32\u003e\u003e, Rc\u003cList\u003e),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n    let a = Rc::new(Cons(Rc::clone(\u0026value), Rc::new(Nil)));\n    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(\u0026a));\n    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(\u0026a));\n    // borrow_mut 方法返回 RefMut\u003cT\u003e 智能指针，可以对其使用解引用运算符并修改其内部值。\n    *value.borrow_mut() += 10;\n    println!(\"a after = {:?}\", a);\n    println!(\"b after = {:?}\", b);\n    println!(\"c after = {:?}\", c);\n}\n// a after = Cons(RefCell { value: 15 }, Nil)\n// b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))\n// c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))\n```\n\n## 引用循环与内存泄漏\n\n```rust\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\nuse std::cell::RefCell;\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell\u003cRc\u003cList\u003e\u003e),\n    Nil,\n}\n\nimpl List {\n    fn tail(\u0026self) -\u003e Option\u003c\u0026RefCell\u003cRc\u003cList\u003e\u003e\u003e {\n        match self {\n            Cons(_, item) =\u003e Some(item),\n            Nil =\u003e None,\n        }\n    }\n}\n\nfn main() {\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\n    println!(\"a initial rc count = {}\", Rc::strong_count(\u0026a));\n    println!(\"a next item = {:?}\", a.tail());\n\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(\u0026a))));\n\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(\u0026a));\n    println!(\"b initial rc count = {}\", Rc::strong_count(\u0026b));\n    println!(\"b next item = {:?}\", b.tail());\n\n    if let Some(link) = a.tail() {\n        // 创建引用循环\n        *link.borrow_mut() = Rc::clone(\u0026b);\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(\u0026b));\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(\u0026a));\n\n    // Uncomment the next line to see that we have a cycle;\n    // it will overflow the stack\n    // println!(\"a next item = {:?}\", a.tail());\n}\n```\n\n## 避免引用循环：将 `Rc\u003cT\u003e` 变为 `Weak\u003cT\u003e`\n\n```rust\nuse std::rc::{Rc, Weak};\nuse std::cell::RefCell;\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell\u003cWeak\u003cNode\u003e\u003e,\n    children: RefCell\u003cVec\u003cRc\u003cNode\u003e\u003e\u003e,\n}\n\nfn main() {\n    // leaf 开始时没有父节点，所以我们新建了一个空的 Weak 引用实例。\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(\u0026leaf),\n        Rc::weak_count(\u0026leaf),\n    );\n\n    {\n        let branch = Rc::new(Node {\n            value: 5,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![Rc::clone(\u0026leaf)]),\n        });\n\n        // 修改 leaf 使其拥有指向父节点的 Weak\u003cNode\u003e 引用。\n        // 使用了 Rc::downgrade 函数创建了一个指向 branch 的 Weak\u003cNode\u003e 引用。\n        *leaf.parent.borrow_mut() = Rc::downgrade(\u0026branch);\n\n        println!(\n            \"branch strong = {}, weak = {}\",\n            Rc::strong_count(\u0026branch),\n            Rc::weak_count(\u0026branch),\n        );\n\n        println!(\n            \"leaf strong = {}, weak = {}\",\n            Rc::strong_count(\u0026leaf),\n            Rc::weak_count(\u0026leaf),\n        );\n    }\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(\u0026leaf),\n        Rc::weak_count(\u0026leaf),\n    );\n}\n```\n"}]}},"page":"/[...param]","query":{"param":["data-type","pointer"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"指针"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>