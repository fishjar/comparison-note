<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>切片操作</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>切片操作</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="go" autoComplete="off"/>go</label><label class="btn btn-secondary"><input type="checkbox" value="js" autoComplete="off"/>js</label><label class="btn btn-secondary"><input type="checkbox" value="python" autoComplete="off"/>python</label><label class="btn btn-secondary"><input type="checkbox" value="rust" autoComplete="off"/>rust</label></div></div></div></div><div class="card-group"></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"slice","fullPath":"/data-type/array/slice","asPath":"/data-type/array/slice","id":"%2Fdata-type%2Farray%2Fslice","parent":{"name":"array","fullPath":"/data-type/array","asPath":"/data-type/array","id":"%2Fdata-type%2Farray","readme":{"title":"数组/列表/切片","fullPath":"/data-type/array/README.md"}},"readme":{"title":"切片操作","fullPath":"/data-type/array/slice/README.md"},"cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/array/slice/go.md"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/data-type/array/slice/js.md"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/data-type/array/slice/python.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/data-type/array/slice/rust.md"}],"nodes":[]},"content":"","cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/array/slice/go.md","content":"每个数组的大小都是固定的。\n而切片则为数组元素提供动态大小的、灵活的视角。\n在实践中，切片比数组更常用。\n类型 `[]T` 表示一个元素类型为 T 的切片。\n\n`a[low : high]`\n它会选择一个半开区间，包括第一个元素，但排除最后一个元素。\n\n![切片与数组示意图](images/slice.png)\n\n```go\n// 以下表达式创建了一个切片，\n// 它包含 a 中下标从 1 到 3 的元素：\npackage main\nimport \"fmt\"\nfunc main() {\n  primes := [6]int{2, 3, 5, 7, 11, 13}\n  fmt.Println(primes)\n  var s []int = primes[1:4]\n  fmt.Println(s)\n}\n// [2 3 5 7 11 13]\n// [3 5 7]\n\n\n// 切片就像数组的引用\n// - 切片并不存储任何数据，它只是描述了底层数组中的一段。\n// - 更改切片的元素会修改其底层数组中对应的元素。\n// - 与它共享底层数组的切片都会观测到这些修改。\npackage main\nimport \"fmt\"\nfunc main() {\n  names := [4]string{\n    \"John\",\n    \"Paul\",\n    \"George\",\n    \"Ringo\",\n  }\n  fmt.Println(names)\n  a := names[0:2]\n  b := names[1:3]\n  fmt.Println(a, b)\n  b[0] = \"XXX\"\n  fmt.Println(a, b)\n  fmt.Println(names)\n}\n// [John Paul George Ringo]\n// [John Paul] [Paul George]\n// [John XXX] [XXX George]\n// [John XXX George Ringo]\n\n\n// 这是一个数组文法：\n[3]bool{true, true, false}\n\n// 切片文法类似于没有长度的数组文法。\n// 下面这样则会创建一个和上面相同的数组，\n// 然后构建一个引用了它的切片：\n[]bool{true, true, false}\n\n\npackage main\nimport \"fmt\"\nfunc main() {\n  q := []int{2, 3, 5, 7, 11, 13}\n  fmt.Println(q)\n  r := []bool{true, false, true, true, false, true}\n  fmt.Println(r)\n  s := []struct {\n    i int\n    b bool\n  }{\n    {2, true},\n    {3, false},\n    {5, true},\n    {7, true},\n    {11, false},\n    {13, true},\n  }\n  fmt.Println(s)\n}\n// [2 3 5 7 11 13]\n// [true false true true false true]\n// [{2 true} {3 false} {5 true} {7 true} {11 false} {13 true}]\n\n\n// 在进行切片时，你可以利用它的默认行为来忽略上下界。\n// 切片下界的默认值为 0，上界则是该切片的长度。\nvar a [10]int\n// 以下切片是等价的：\na[0:10]\na[:10]\na[0:]\na[:]\n\npackage main\nimport \"fmt\"\nfunc main() {\n  s := []int{2, 3, 5, 7, 11, 13}\n  s = s[1:4]\n  fmt.Println(s)\n  s = s[:2]\n  fmt.Println(s)\n  s = s[1:]\n  fmt.Println(s)\n}\n// [3 5 7]\n// [3 5]\n// [5]\n\n\n// 切片拥有 长度 和 容量。\n// 切片的长度就是它所包含的元素个数。\n// 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。\n// 切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。\n// 你可以通过重新切片来扩展一个切片，给它提供足够的容量。\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n  s := []int{2, 3, 5, 7, 11, 13}\n  printSlice(s)\n\n  // 截取切片使其长度为 0\n  s = s[:0]\n  printSlice(s)\n\n  // 拓展其长度\n  s = s[:4]\n  printSlice(s)\n\n  // 舍弃前两个值\n  s = s[2:]\n  printSlice(s)\n\n  s = s[0:4]\n  printSlice(s)\n\n  s = s[0:6]\n  printSlice(s)\n}\nfunc printSlice(s []int) {\n  fmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)\n}\n// len=6 cap=6 [2 3 5 7 11 13]\n// len=0 cap=6 []\n// len=4 cap=6 [2 3 5 7]\n// len=2 cap=4 [5 7]\n// len=4 cap=4 [5 7 11 13]\n// panic: runtime error: slice bounds out of range\n\n\n// 切片的零值是 nil。\n// nil 切片的长度和容量为 0 且没有底层数组。\npackage main\nimport \"fmt\"\nfunc main() {\n  var s []int\n  fmt.Println(s, len(s), cap(s))\n  if s == nil {\n    fmt.Println(\"nil!\")\n  }\n}\n// [] 0 0\n// nil!\n\n\n// 切片可以用内建函数 make 来创建，这也是你创建动态数组的方式。\n// make 函数会分配一个元素为零值的数组并返回一个引用了它的切片：\n// 要指定它的容量，需向 make 传入第三个参数：\npackage main\nimport \"fmt\"\nfunc main() {\n  a := make([]int, 5)\n  printSlice(\"a\", a)\n\n  b := make([]int, 0, 5)\n  printSlice(\"b\", b)\n\n  c := b[:2]\n  printSlice(\"c\", c)\n\n  d := c[2:5]\n  printSlice(\"d\", d)\n}\nfunc printSlice(s string, x []int) {\n  fmt.Printf(\"%s len=%d cap=%d %v\\n\",\n    s, len(x), cap(x), x)\n}\n// a len=5 cap=5 [0 0 0 0 0]\n// b len=0 cap=5 []\n// c len=2 cap=5 [0 0]\n// d len=3 cap=3 [0 0 0]\n\n\n// 切片可包含任何类型，甚至包括其它的切片。\npackage main\nimport (\n  \"fmt\"\n  \"strings\"\n)\nfunc main() {\n  // 创建一个井字板（经典游戏）\n  board := [][]string{\n    []string{\"_\", \"_\", \"_\"},\n    []string{\"_\", \"_\", \"_\"},\n    []string{\"_\", \"_\", \"_\"},\n  }\n  // 两个玩家轮流打上 X 和 O\n  board[0][0] = \"X\"\n  board[2][2] = \"O\"\n  board[1][2] = \"X\"\n  board[1][0] = \"O\"\n  board[0][2] = \"X\"\n  for i := 0; i \u003c len(board); i++ {\n    fmt.Printf(\"%s\\n\", strings.Join(board[i], \" \"))\n  }\n}\n// X _ X\n// O _ X\n// _ _ O\n\n\n// 为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 append 函数。\n// append 的结果是一个包含原切片所有元素加上新添加元素的切片。\n// 当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。\n// 返回的切片会指向这个新分配的数组。\npackage main\nimport \"fmt\"\nfunc main() {\n  var s []int\n  printSlice(s)\n  // 添加一个空切片\n  s = append(s, 0)\n  printSlice(s)\n  // 这个切片会按需增长\n  s = append(s, 1)\n  printSlice(s)\n  // 可以一次性添加多个元素\n  s = append(s, 2, 3, 4)\n  printSlice(s)\n}\nfunc printSlice(s []int) {\n  fmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)\n}\n// len=0 cap=0 []\n// len=1 cap=2 [0]\n// len=2 cap=2 [0 1]\n// len=5 cap=8 [0 1 2 3 4]\n\n\n// 实现 Pic。\n// 它应当返回一个长度为 dy 的切片，\n// 其中每个元素是一个长度为 dx，元素类型为 uint8 的切片。\n// 当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像。\npackage main\nimport \"golang.org/x/tour/pic\"\n//import \"fmt\"\nfunc Pic(dx, dy int) [][]uint8 {\n  //fmt.Println(dx, dy)\n  qie := make([][]uint8, dy)\n  // fmt.Println(qie)\n  for i := 0; i \u003c dy; i++ {\n    qie[i] = make([]uint8, dx)\n    for j := 0; j \u003c dx; j++ {\n      qie[i][j] = uint8(i-j)\n    }\n  }\n  return qie\n}\nfunc main() {\n  pic.Show(Pic)\n}\n\n\n// 将一个切片追加到另一个切片中\nx := []int{1,2,3}\ny := []int{4,5,6}\nx = append(x, y...)\nfmt.Println(x)\n\n\n// 字符串切片拼接\nstrings.Join(os.Args[1:], \" \")\n// 字符串切片\nstrings.Split(string(data), \"\\n\")\n```\n\n翻转切片\n\n```go\n// 复制一个slice只是对底层的数组创建了一个新的slice别名\n// 向函数传递slice将允许在函数内部修改底层数组\nfunc reverse(s []int) {\n    for i, j := 0, len(s)-1; i \u003c j; i, j = i+1, j-1 {\n        s[i], s[j] = s[j], s[i]\n    }\n}\n\na := [...]int{0, 1, 2, 3, 4, 5}\nreverse(a[:])\nfmt.Println(a) // \"[5 4 3 2 1 0]\"\n\n// 一种将slice元素循环向左旋转n个元素的方法是三次调用reverse反转函数\n// 第一次是反转开头的n个元素，然后是反转剩下的元素，最后是反转整个slice的元素。\n// 如果是向右循环旋转，则将第三个函数调用移到第一个调用位置就可以了。\ns := []int{0, 1, 2, 3, 4, 5}\nreverse(s[:2])\nreverse(s[2:])\nreverse(s)\nfmt.Println(s) // \"[2 3 4 5 0 1]\"\n```\n\n过滤空字符串\n\n```go\nfunc nonempty(strings []string) []string {\n    i := 0\n    for _, s := range strings {\n        if s != \"\" {\n            strings[i] = s\n            i++\n        }\n    }\n    return strings[:i]\n}\n\ndata := []string{\"one\", \"\", \"three\"}\nfmt.Printf(\"%q\\n\", nonempty(data)) // `[\"one\" \"three\"]`\nfmt.Printf(\"%q\\n\", data)           // `[\"one\" \"three\" \"three\"]`\n\nfunc nonempty2(strings []string) []string {\n    out := strings[:0] // zero-length slice of original\n    for _, s := range strings {\n        if s != \"\" {\n            out = append(out, s)\n        }\n    }\n    return out\n}\n```\n\n模拟栈（stack）\n\n```go\nstack = append(stack, v) // push v\ntop := stack[len(stack)-1] // top of stack\nstack = stack[:len(stack)-1] // pop\n```\n\n删除 slice 中间的某个元素并保存原有的元素顺序\n\n```go\nfunc remove(slice []int, i int) []int {\n    copy(slice[i:], slice[i+1:])\n    return slice[:len(slice)-1]\n}\nfunc main() {\n    s := []int{5, 6, 7, 8, 9}\n    fmt.Println(remove(s, 2)) // \"[5 6 8 9]\"\n}\n```\n\n如果删除元素后不用保持原来顺序\n\n```go\nfunc remove(slice []int, i int) []int {\n    slice[i] = slice[len(slice)-1]\n    return slice[:len(slice)-1]\n}\nfunc main() {\n    s := []int{5, 6, 7, 8, 9}\n    fmt.Println(remove(s, 2)) // \"[5 6 9 8]\n}\n```\n"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/data-type/array/slice/js.md","content":"```js\n// arr.slice(start, end);\nvar a = [\"a\", \"b\", \"c\"];\na.slice(0); // [\"a\", \"b\", \"c\"]\na.slice(1); // [\"b\", \"c\"]\na.slice(1, 2); // [\"b\"]\na.slice(2, 6); // [\"c\"]\na.slice(); // [\"a\", \"b\", \"c\"]\n\nvar a = [\"a\", \"b\", \"c\"];\na.slice(-2); // [\"b\", \"c\"]\na.slice(-2, -1); // [\"b\"]\n\nvar a = [\"a\", \"b\", \"c\"];\na.slice(4); // []\na.slice(2, 1); // []\n\n// arr.splice(start, count, addElement1, addElement2, ...);\nvar a = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\na.splice(4, 2); // [\"e\", \"f\"]\na; // [\"a\", \"b\", \"c\", \"d\"]\n\nconst someList = [\"a\", \"b\", \"c\"];\nsomeList.splice(1, 1);\n// a\n// c\nsomeList.forEach((element) =\u003e {\n  console.log(element);\n});\n```\n"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/data-type/array/slice/python.md","content":"```python\noriginal_list = [1, 2, 3]\nnew_list = original_list[:]  # or original_list.copy()\noriginal_list[2] = 4\n# 1\n# 2\n# 3\nfor x in new_list:\n    print(x)\n```\n\n```sh\n\u003e\u003e\u003e squares = [1, 4, 9, 16, 25]\n\u003e\u003e\u003e squares\n[1, 4, 9, 16, 25]\n\n# 列表也支持索引和切片:\n\u003e\u003e\u003e squares[0]  # indexing returns the item\n1\n\u003e\u003e\u003e squares[-1]\n25\n\u003e\u003e\u003e squares[-3:]  # slicing returns a new list\n[9, 16, 25]\n\n# 切片会返回列表的一个新的(浅)拷贝:\n\u003e\u003e\u003e squares[:]\n[1, 4, 9, 16, 25]\n\n# del语句\n\u003e\u003e\u003e a = [-1, 1, 66.25, 333, 333, 1234.5]\n\u003e\u003e\u003e del a[0]\n\u003e\u003e\u003e a\n[1, 66.25, 333, 333, 1234.5]\n\u003e\u003e\u003e del a[2:4]\n\u003e\u003e\u003e a\n[1, 66.25, 1234.5]\n\u003e\u003e\u003e del a[:]\n\u003e\u003e\u003e a\n[]\n\n# del 也可以被用来删除整个变量\n\u003e\u003e\u003e del a\n```\n"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/data-type/array/slice/rust.md","content":"字符串 `slice`（`string slice`）是 `String` 中一部分值的引用\n\n```rust\nlet s = String::from(\"hello world\");\n\nlet hello = \u0026s[0..5];\nlet world = \u0026s[6..11];\n\nlet slice = \u0026s[0..2];\nlet slice = \u0026s[..2];\n\nlet len = s.len();\nlet slice = \u0026s[3..len];\nlet slice = \u0026s[3..];\n\nlet len = s.len();\nlet slice = \u0026s[0..len];\nlet slice = \u0026s[..];\n```\n\n```rust\nfn first_word(s: \u0026String) -\u003e \u0026str {\n    let bytes = s.as_bytes();\n    for (i, \u0026item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return \u0026s[0..i];\n        }\n    }\n    \u0026s[..]\n}\n```\n\n```rust\nfn first_word(s: \u0026str) -\u003e \u0026str {\n    let bytes = s.as_bytes();\n    for (i, \u0026item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return \u0026s[0..i];\n        }\n    }\n    \u0026s[..]\n}\n\nfn main() {\n    let my_string = String::from(\"hello world\");\n\n    // `first_word` 接受 `String` 的切片，无论是部分还是全部\n    let word = first_word(\u0026my_string[0..6]);\n    let word = first_word(\u0026my_string[..]);\n    // `first_word` 也接受 `String` 的引用，\n    // 这等同于 `String` 的全部切片\n    let word = first_word(\u0026my_string);\n\n    let my_string_literal = \"hello world\";\n\n    // `first_word` 接受字符串字面量的切片，无论是部分还是全部\n    let word = first_word(\u0026my_string_literal[0..6]);\n    let word = first_word(\u0026my_string_literal[..]);\n\n    // 因为字符串字面值**就是**字符串 slice，\n    // 这样写也可以，即不使用 slice 语法！\n    let word = first_word(my_string_literal);\n}\n```\n"}]}},"page":"/[...param]","query":{"param":["data-type","array","slice"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"切片操作"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>