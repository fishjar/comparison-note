<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>结构体</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>结构体</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="c" autoComplete="off"/>c</label><label class="btn btn-secondary"><input type="checkbox" value="go" autoComplete="off"/>go</label><label class="btn btn-secondary"><input type="checkbox" value="rust" autoComplete="off"/>rust</label></div></div></div></div><div class="card-group"></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"struct","fullPath":"/data-type/struct","asPath":"/data-type/struct","id":"%2Fdata-type%2Fstruct","parent":{"name":"data-type","fullPath":"/data-type","asPath":"/data-type","id":"%2Fdata-type","readme":{"title":"数据类型","fullPath":"/data-type/README.md"}},"readme":{"title":"结构体","fullPath":"/data-type/struct/README.md"},"cards":[{"name":"c.md","baseName":"c","extName":".md","fullPath":"/data-type/struct/c.md"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/struct/go.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/data-type/struct/rust.md"}],"nodes":[]},"content":"","cards":[{"name":"c.md","baseName":"c","extName":".md","fullPath":"/data-type/struct/c.md","content":"```c++\nstruct fraction {\n  int numerator;\n  int denominator;\n};\nstruct fraction f1;\nf1.numerator = 22;\nf1.denominator = 7;\n\n\nstruct car {\n  char* name;\n  float price;\n  int speed;\n};\nstruct car saturn = {\"Saturn SL/2\", 16000.99, 175};\n// or\nstruct car saturn = {.speed=172, .name=\"Saturn SL/2\"};\n// 修改属性值\nsaturn.speed = 168;\n\n\n// struct 的数据类型声明语句与变量的声明语句合并\nstruct book {\n  char title[500];\n  char author[100];\n  float value;\n} b1;\n// 省略类型名\nstruct {\n  char title[500];\n  char author[100];\n  float value;\n} b1;\n// 声明变量的同时，对变量赋值\nstruct {\n  char title[500];\n  char author[100];\n  float value;\n} b1 = {\"Harry Potter\", \"J. K. Rowling\", 10.0},\n  b2 = {\"Cancer Ward\", \"Aleksandr Solzhenitsyn\", 7.85};\n\n\n// typedef命令可以为 struct 结构指定一个别名\ntypedef struct cell_phone {\n  int cell_no;\n  float minutes_of_charge;\n} phone;\nphone p = {5551234, 5};\n\n\n// 指针变量也可以指向struct结构\nstruct book {\n  char title[500];\n  char author[100];\n  float value;\n}* b1;\n// 或者写成两个语句\nstruct book {\n  char title[500];\n  char author[100];\n  float value;\n};\nstruct book* b1;\n\n\n// struct 结构也可以作为数组成员\nstruct fraction {\n  int numerator;\n  int denominator;\n};\nstruct fraction numbers[1000];\nnumbers[0].numerator = 22;\nnumbers[0].denominator = 7;\n```\n\n`struct foo`有三个属性，在 64 位计算机上占用的存储空间分别是：\n\n- `int a`占 4 个字节，\n- 指针`char* b`占 8 个字节，\n- `char c`占 1 个字节。\n\n它们加起来，一共是 13 个字节（4 + 8 + 1）。\n但是实际上，`struct foo`会占用 24 个字节\n\n```c++\nstruct foo {\n  int a;\n  char* b;\n  char c;\n};\nprintf(\"%d\\n\", sizeof(struct foo)); // 24\n\n// 真实的结构\nstruct foo {\n  int a;        // 4\n  char pad1[4]; // 填充4字节\n  char *b;      // 8\n  char c;       // 1\n  char pad2[7]; // 填充7字节\n};\nprintf(\"%d\\n\", sizeof(struct foo)); // 24\n\n// 存储空间递增的顺序，定义每个属性\nstruct foo {\n  char c;\n  int a;\n  char* b;\n};\nprintf(\"%d\\n\", sizeof(struct foo)); // 16\n```\n\n## struct 的复制\n\n```c++\nstruct cat { char name[30]; short age; } a, b;\n\nstrcpy(a.name, \"Hula\");\na.age = 3;\n\nb = a;\nb.name[0] = 'M';\n\nprintf(\"%s\\n\", a.name); // Hula\nprintf(\"%s\\n\", b.name); // Mula\n```\n\n## struct 指针\n\n```c++\n#include \u003cstdio.h\u003e\n\nstruct turtle {\n  char* name;\n  char* species;\n  int age;\n};\n\nvoid happy(struct turtle t) {\n  t.age = t.age + 1;\n}\n\nint main() {\n  struct turtle myTurtle = {\"MyTurtle\", \"sea turtle\", 99};\n  happy(myTurtle);\n  printf(\"Age is %i\\n\", myTurtle.age); // 输出 99\n  return 0;\n}\n```\n\n```c++\n#include \u003cstdio.h\u003e\n\nstruct turtle {\n  char* name;\n  char* species;\n  int age;\n};\n\nvoid happy(struct turtle* t) {\n  (*t).age = (*t).age + 1;\n}\n// 或者使用箭头运算符\n// ptr == \u0026myStruct\n// myStruct.prop == (*ptr).prop == ptr-\u003eprop\nvoid happy(struct turtle* t) {\n  t-\u003eage = t-\u003eage + 1;\n}\n\nint main() {\n  struct turtle myTurtle = {\"MyTurtle\", \"sea turtle\", 99};\n  happy(\u0026myTurtle);\n  printf(\"Age is %i\\n\", myTurtle.age); // 输出 99\n  return 0;\n}\n```\n\n## struct 的嵌套\n\n```c++\nstruct species {\n  char* name;\n  int kinds;\n};\nstruct fish {\n  char* name;\n  int age;\n  struct species breed;\n};\n\n// 赋值\n// 写法一\nstruct fish shark = {\"shark\", 9, {\"Selachimorpha\", 500}};\n\n// 写法二\nstruct species myBreed = {\"Selachimorpha\", 500};\nstruct fish shark = {\"shark\", 9, myBreed};\n\n// 写法三\nstruct fish shark = {\n  .name=\"shark\",\n  .age=9,\n  .breed={\"Selachimorpha\", 500}\n};\n\n// 写法四\nstruct fish shark = {\n  .name=\"shark\",\n  .age=9,\n  .breed.name=\"Selachimorpha\",\n  .breed.kinds=500\n};\n\nprintf(\"Shark's species is %s\", shark.breed.name);\n\n\n\nstruct name {\n  char first[50];\n  char last[50];\n};\nstruct student {\n  struct name name;\n  short age;\n  char sex;\n} student1;\n\nstrcpy(student1.name.first, \"Harry\");\nstrcpy(student1.name.last, \"Potter\");\n// or\nstruct name myname = {\"Harry\", \"Potter\"};\nstudent1.name = myname;\n```\n\n### 链表结构\n\n```c++\nstruct node {\n  int data;\n  struct node* next;\n};\n\nstruct node* head;\n\n// 生成一个三个节点的列表 (11)-\u003e(22)-\u003e(33)\nhead = malloc(sizeof(struct node));\n\nhead-\u003edata = 11;\nhead-\u003enext = malloc(sizeof(struct node));\n\nhead-\u003enext-\u003edata = 22;\nhead-\u003enext-\u003enext = malloc(sizeof(struct node));\n\nhead-\u003enext-\u003enext-\u003edata = 33;\nhead-\u003enext-\u003enext-\u003enext = NULL;\n\n// 遍历这个列表\nfor (struct node *cur = head; cur != NULL; cur = cur-\u003enext) {\n  printf(\"%d\\n\", cur-\u003edata);\n}\n```\n\n## 位字段\n\n```c++\nstruct {\n  unsigned int ab:1;\n  unsigned int cd:1;\n  unsigned int ef:1;\n  unsigned int gh:1;\n} synth;\n\nsynth.ab = 0;\nsynth.cd = 1;\n```\n\n## 弹性数组成员\n\n弹性成员的数组，必须是 `struct` 结构的最后一个属性。\n另外，除了弹性数组成员，`struct` 结构必须至少还有一个其他属性。\n\n```c++\nstruct vstring {\n  int len;\n  char chars[];\n};\nstruct vstring* str = malloc(sizeof(struct vstring) + n * sizeof(char));\nstr-\u003elen = n;\n```\n"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/struct/go.md","content":"一个结构体（struct）就是一组字段（field）。\n\n```go\npackage main\nimport \"fmt\"\ntype Vertex struct {\n  X int\n  Y int\n}\nfunc main() {\n  fmt.Println(Vertex{1, 2})\n  fmt.Println(Vertex{X:1, Y:2})\n}\n\n// 结构体字段使用点号来访问。\npackage main\nimport \"fmt\"\ntype Vertex struct {\n  X int\n  Y int\n}\nfunc main() {\n  v := Vertex{1, 2}\n  v.X = 4\n  fmt.Println(v.X)\n}\n\n\n// 如果我们有一个指向结构体的指针 p，\n// 那么可以通过 (*p).X 来访问其字段 X。\n//不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，\n//直接写 p.X 就可以。\npackage main\nimport \"fmt\"\ntype Vertex struct {\n  X int\n  Y int\n}\nfunc main() {\n  v := Vertex{1, 2}\n  p := \u0026v\n  // var p int = \u0026v\n  fmt.Println(p)\n  fmt.Println(*p)\n  p.X = 3\n  // (*p).X = 3\n  fmt.Println(v)\n}\n// \u0026{1 2}\n// {1 2}\n// {3 2}\n\n\n// 仅列出部分字段。（字段名的顺序无关。）\npackage main\nimport \"fmt\"\ntype Vertex struct {\n  X, Y int\n}\nvar (\n  v1 = Vertex{1, 2}  // 创建一个 Vertex 类型的结构体\n  v2 = Vertex{X: 1}  // Y:0 被隐式地赋予\n  v3 = Vertex{}      // X:0 Y:0\n  p  = \u0026Vertex{1, 2} // 创建一个 *Vertex 类型的结构体（指针）\n)\nfunc main() {\n  fmt.Println(v1, p, v2, v3)\n}\n// {1 2} \u0026{1 2} {1 0} {0 0}\n\n\n// struct的匿名字段\npackage main\nimport \"fmt\"\ntype Human struct {\n  name string\n  age int\n  weight int\n}\n\ntype Student struct {\n  Human  // 匿名字段，那么默认Student就包含了Human的所有字段\n  speciality string\n}\n\nfunc main() {\n  // 我们初始化一个学生\n  mark := Student{Human{\"Mark\", 25, 120}, \"Computer Science\"}\n\n  // 我们访问相应的字段\n  fmt.Println(\"His name is \", mark.name)\n  fmt.Println(\"His age is \", mark.age)\n  fmt.Println(\"His weight is \", mark.weight)\n  fmt.Println(\"His speciality is \", mark.speciality)\n  // 修改对应的备注信息\n  mark.speciality = \"AI\"\n  fmt.Println(\"Mark changed his speciality\")\n  fmt.Println(\"His speciality is \", mark.speciality)\n  // 修改他的年龄信息\n  fmt.Println(\"Mark become old\")\n  mark.age = 46\n  fmt.Println(\"His age is\", mark.age)\n  // 修改他的体重信息\n  fmt.Println(\"Mark is not an athlet anymore\")\n  mark.weight += 60\n  fmt.Println(\"His weight is\", mark.weight)\n}\n\n\npackage main\nimport \"fmt\"\ntype Skills []string\ntype Human struct {\n  name string\n  age int\n  weight int\n}\ntype Student struct {\n  Human  // 匿名字段，struct\n  Skills // 匿名字段，自定义的类型string slice\n  int    // 内置类型作为匿名字段\n  speciality string\n}\nfunc main() {\n  // 初始化学生Jane\n  jane := Student{Human:Human{\"Jane\", 35, 100}, speciality:\"Biology\"}\n  // 现在我们来访问相应的字段\n  fmt.Println(\"Her name is \", jane.name)\n  fmt.Println(\"Her age is \", jane.age)\n  fmt.Println(\"Her weight is \", jane.weight)\n  fmt.Println(\"Her speciality is \", jane.speciality)\n  // 我们来修改他的skill技能字段\n  jane.Skills = []string{\"anatomy\"}\n  fmt.Println(\"Her skills are \", jane.Skills)\n  fmt.Println(\"She acquired two new ones \")\n  jane.Skills = append(jane.Skills, \"physics\", \"golang\")\n  fmt.Println(\"Her skills now are \", jane.Skills)\n  // 修改匿名内置类型字段\n  jane.int = 3\n  fmt.Println(\"Her preferred number is\", jane.int)\n}\n```\n\n```go\ntype Employee struct {\n    ID        int\n    Name      string\n    Address   string\n    DoB       time.Time\n    Position  string\n    Salary    int\n    ManagerID int\n}\nvar dilbert Employee\n\nvar employeeOfTheMonth *Employee = \u0026dilbert\nemployeeOfTheMonth.Position += \" (proactive team player)\" // 相当于下一行\n(*employeeOfTheMonth).Position += \" (proactive team player)\"\n\n// 如果要在函数内部修改结构体成员的话，用指针传入是必须的\nfunc AwardAnnualRaise(e *Employee) {\n    e.Salary = e.Salary * 105 / 100\n}\n\npp := \u0026Point{1, 2} // 等价于下面两行\npp := new(Point)\n*pp = Point{1, 2}\n```\n\n一个命名为 S 的结构体类型将不能再包含 S 类型的成员：\n因为一个聚合的值不能包含它自身。\n（该限制同样适应于数组。）\n但是 S 类型的结构体可以包含\\*S 指针类型的成员，\n这可以让我们创建递归的数据结构，比如链表和树结构等。\n\n```go\ntype tree struct {\n    value       int\n    left, right *tree\n}\n```\n\n如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的。\n因此和其他可比较的类型一样，可以用于 map 的 key 类型\n\n```go\ntype Point struct{ X, Y int }\n\np := Point{1, 2}\nq := Point{2, 1}\nfmt.Println(p.X == q.X \u0026\u0026 p.Y == q.Y) // \"false\"\nfmt.Println(p == q)                   // \"false\"\n```\n\nGo 语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；\n这类成员就叫匿名成员。\n匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。\n\n```go\ntype Point struct {\n    X, Y int\n}\ntype Circle struct {\n    Center Point\n    Radius int\n}\ntype Wheel struct {\n    Circle Circle\n    Spokes int\n}\nvar w Wheel\nw.Circle.Center.X = 8\nw.Circle.Center.Y = 8\nw.Circle.Radius = 5\nw.Spokes = 20\n\n// 下面的代码中，Circle和Wheel各自都有一个匿名成员。\n// 我们可以说Point类型被嵌入到了Circle结构体，\n// 同时Circle类型被嵌入到了Wheel结构体。\ntype Circle struct {\n    Point\n    Radius int\n}\ntype Wheel struct {\n    Circle\n    Spokes int\n}\n\n// 匿名成员Circle和Point都有自己的名字——就是命名的类型名字\n// 但是这些名字在点操作符中是可选的。\nvar w Wheel\nw.X = 8            // equivalent to w.Circle.Point.X = 8\nw.Y = 8            // equivalent to w.Circle.Point.Y = 8\nw.Radius = 5       // equivalent to w.Circle.Radius = 5\nw.Spokes = 20\n\n// 不幸的是，结构体字面值并没有简短表示匿名成员的语法，\n// 因此下面的语句都不能编译通过：\nw = Wheel{8, 8, 5, 20}                       // compile error: unknown fields\nw = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields\n\n// 结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法\nw = Wheel{Circle{Point{8, 8}, 5}, 20}\nw = Wheel{\n    Circle: Circle{\n        Point:  Point{X: 8, Y: 8},\n        Radius: 5,\n    },\n    Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)\n}\nfmt.Printf(\"%#v\\n\", w)\n// Output:\n// Wheel{Circle:Circle{Point:Point{X:8, Y:8}, Radius:5}, Spokes:20}\nw.X = 42\nfmt.Printf(\"%#v\\n\", w)\n// Output:\n// Wheel{Circle:Circle{Point:Point{X:42, Y:8}, Radius:5}, Spokes:20}\n```\n\n一个 struct 类型也可能会有多个匿名字段。\n\n种类型的值便会拥有 Point 和 RGBA 类型的所有方法，\n以及直接定义在 ColoredPoint 中的方法。\n当编译器解析一个选择器到方法时，比如 p.ScaleBy，\n它会首先去找直接定义在这个类型里的 ScaleBy 方法，\n然后找被 ColoredPoint 的内嵌字段们引入的方法，\n然后去找 Point 和 RGBA 的内嵌字段引入的方法，然后一直递归向下找。\n如果选择器有二义性的话编译器会报错，比如你在同一级里有两个同名的方法。\n\n```go\ntype ColoredPoint struct {\n    Point\n    color.RGBA\n}\n```\n\n一个小 trick\n\n```go\nvar (\n    mu sync.Mutex // guards mapping\n    mapping = make(map[string]string)\n)\n\nfunc Lookup(key string) string {\n    mu.Lock()\n    v := mapping[key]\n    mu.Unlock()\n    return v\n}\n```\n\n改进后\n\n```go\n// 给新的变量起了一个更具表达性的名字：cache\n// 因为sync.Mutex字段也被嵌入到了这个struct里，\n// 其Lock和Unlock方法也就都被引入到了这个匿名结构中了\nvar cache = struct {\n    sync.Mutex\n    mapping map[string]string\n}{\n    mapping: make(map[string]string),\n}\n\n\nfunc Lookup(key string) string {\n    cache.Lock()\n    v := cache.mapping[key]\n    cache.Unlock()\n    return v\n}\n```\n\n将一个 Go 语言中类似 movies 的结构体 slice 转为 JSON 的过程叫编组（marshaling）。\n编组通过调用 json.Marshal 函数完成\n\n```go\n// Color成员的Tag还带了一个额外的omitempty选项，\n// 表示当Go语言结构体成员为空或零值时不生成JSON对象（这里false为零值）。\ntype Movie struct {\n    Title  string\n    Year   int  `json:\"released\"`\n    Color  bool `json:\"color,omitempty\"`\n    Actors []string\n}\nvar movies = []Movie{\n    {Title: \"Casablanca\", Year: 1942, Color: false,\n        Actors: []string{\"Humphrey Bogart\", \"Ingrid Bergman\"}},\n    {Title: \"Cool Hand Luke\", Year: 1967, Color: true,\n        Actors: []string{\"Paul Newman\"}},\n    {Title: \"Bullitt\", Year: 1968, Color: true,\n        Actors: []string{\"Steve McQueen\", \"Jacqueline Bisset\"}},\n    // ...\n}\ndata, err := json.Marshal(movies)\nif err != nil {\n    log.Fatalf(\"JSON marshaling failed: %s\", err)\n}\nfmt.Printf(\"%s\\n\", data)\n\n```\n\n```json\n[{\"Title\":\"Casablanca\",\"released\":1942,\"Actors\":[\"Humphrey Bogart\",\"Ingr\nid Bergman\"]},{\"Title\":\"Cool Hand Luke\",\"released\":1967,\"color\":true,\"Ac\ntors\":[\"Paul Newman\"]},{\"Title\":\"Bullitt\",\"released\":1968,\"color\":true,\"\nActors\":[\"Steve McQueen\",\"Jacqueline Bisset\"]}]\n```\n\n```go\n// json.MarshalIndent函数将产生整齐缩进的输出\ndata, err := json.MarshalIndent(movies, \"\", \"    \")\nif err != nil {\n    log.Fatalf(\"JSON marshaling failed: %s\", err)\n}\nfmt.Printf(\"%s\\n\", data)\n```\n\n```json\n[\n  {\n    \"Title\": \"Casablanca\",\n    \"released\": 1942,\n    \"Actors\": [\"Humphrey Bogart\", \"Ingrid Bergman\"]\n  },\n  {\n    \"Title\": \"Cool Hand Luke\",\n    \"released\": 1967,\n    \"color\": true,\n    \"Actors\": [\"Paul Newman\"]\n  },\n  {\n    \"Title\": \"Bullitt\",\n    \"released\": 1968,\n    \"color\": true,\n    \"Actors\": [\"Steve McQueen\", \"Jacqueline Bisset\"]\n  }\n]\n```\n\n编码的逆操作是解码，对应将 JSON 数据解码为 Go 语言的数据结构，\nGo 语言中一般叫 unmarshaling，通过 json.Unmarshal 函数完成。\n\n```go\nvar titles []struct{ Title string }\nif err := json.Unmarshal(data, \u0026titles); err != nil {\n    log.Fatalf(\"JSON unmarshaling failed: %s\", err)\n}\nfmt.Println(titles) // \"[{Casablanca} {Cool Hand Luke} {Bullitt}]\"\n```\n\n## 结构体嵌入\n\n```go\npackage main\nimport \"fmt\"\n\ntype base struct {\n    num int\n}\nfunc (b base) describe() string {\n    return fmt.Sprintf(\"base with num=%v\", b.num)\n}\n\ntype container struct {\n    base\n    str string\n}\n\nfunc main() {\n    co := container{\n        base: base{\n            num: 1,\n        },\n        str: \"some name\",\n    }\n\n    fmt.Printf(\"co={num: %v, str: %v}\\n\", co.num, co.str)\n    fmt.Println(\"also num:\", co.base.num)\n    fmt.Println(\"describe:\", co.describe())\n\n    // 因为嵌入了 base ，在这里我们看到 container 也实现了 describer 接口\n    type describer interface {\n        describe() string\n    }\n    var d describer = co\n    fmt.Println(\"describer:\", d.describe())\n}\n```\n"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/data-type/struct/rust.md","content":"结构体（structure，缩写成 struct）有 3 种类型\n\n- 元组结构体（tuple struct），事实上就是具名元组而已。\n- 经典的 C 语言风格结构体（C struct）。\n- 单元结构体（unit struct），不带字段，在泛型中很有用。\n\n```rust\n#[derive(Debug)]\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn build_user(email: String, username: String) -\u003e User {\n    User {\n        email,\n        username,\n        active: true,\n        sign_in_count: 1,\n    }\n}\n\nfn main() {\n    let mut user1 = build_user(\n        String::from(\"someone@example.com\"),\n        String::from(\"someusername123\"),\n    );\n    user1.email = String::from(\"anotheremail@example.com\");\n    println!(\"{:?}\", user1);\n\n    // 在这个例子中，我们在创建 user2 后不能再使用 user1，\n    // 因为 user1 的 username 字段中的 String 被移到 user2 中。\n    // 如果我们给 user2 的 email 和 username 都赋予新的 String 值，\n    // 从而只使用 user1 的 active 和 sign_in_count 值，\n    // 那么 user1 在创建 user2 后仍然有效。\n    let user2 = User {\n        email: String::from(\"another@example.com\"),\n        ..user1\n    };\n    println!(\"{:#?}\", user2);\n}\n```\n\n```sh\nUser { active: true, username: \"someusername123\", email: \"anotheremail@example.com\", sign_in_count: 1 }\nUser {\n    active: true,\n    username: \"someusername123\",\n    email: \"another@example.com\",\n    sign_in_count: 1,\n}\n```\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    // 方法\n    fn area(\u0026self) -\u003e u32 {\n        self.width * self.height\n    }\n    // 带参数的方法\n    fn can_hold(\u0026self, other: \u0026Rectangle) -\u003e bool {\n        self.width \u003e other.width \u0026\u0026 self.height \u003e other.height\n    }\n    // 关联函数（associated function）\n    fn square(size: u32) -\u003e Rectangle {\n        Rectangle {\n            width: size,\n            height: size,\n        }\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        rect1.area()\n    );\n}\n```\n\n## 打印结构体\n\n```rust\n// 在结构体定义之前加上外部属性 #[derive(Debug)]\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"rect1 is {:?}\", rect1);\n}\n```\n\n```rust\n// 使用 dbg! 宏\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let scale = 2;\n    let rect1 = Rectangle {\n        width: dbg!(30 * scale),\n        height: 50,\n    };\n\n    dbg!(\u0026rect1);\n}\n```\n\n## 元组结构体（tuple struct）\n\n```rust\n// black 和 origin 值的类型不同，因为它们是不同的元组结构体的实例。\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}\n```\n\n## 类单元结构体（unit-like structs）\n\n类单元结构体常常在你想要在某个类型上实现 `trait` 但不需要在类型中存储数据的时候发挥作用。\n\n```rust\nstruct AlwaysEqual;\n\nfn main() {\n    let subject = AlwaysEqual;\n}\n```\n"}]}},"page":"/[...param]","query":{"param":["data-type","struct"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"结构体"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>