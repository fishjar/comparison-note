<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>字符串</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>字符串</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="c" autoComplete="off"/>c</label><label class="btn btn-secondary"><input type="checkbox" value="dart" autoComplete="off"/>dart</label><label class="btn btn-secondary"><input type="checkbox" value="go" autoComplete="off"/>go</label><label class="btn btn-secondary"><input type="checkbox" value="js" autoComplete="off"/>js</label><label class="btn btn-secondary"><input type="checkbox" value="python" autoComplete="off"/>python</label><label class="btn btn-secondary"><input type="checkbox" value="rust" autoComplete="off"/>rust</label></div></div></div></div><div class="card-group"></div><div style="margin-top:12px" class="card"><div class="card-body"><h6>了解更多</h6><ul><li><a href="/comparison-note/data-type/string/string-concat/">字符串拼接</a><span style="color:#666"> [go]</span></li><li><a href="/comparison-note/data-type/string/string-format/">格式化输出</a><span style="color:#666"> [go, js, python]</span></li><li><a href="/comparison-note/data-type/string/string-replace/">字符串替换</a><span style="color:#666"> [dart, js, python]</span></li><li><a href="/comparison-note/data-type/string/string-search/">字符串查找</a><span style="color:#666"> [dart, go, js, python]</span></li><li><a href="/comparison-note/data-type/string/string-sub/">字符串切割截取</a><span style="color:#666"> [dart, js, python]</span></li><li><a href="/comparison-note/data-type/string/string-templates/">文本模板</a><span style="color:#666"> [go]</span></li><li><a href="/comparison-note/data-type/string/string-uppercase/">字符串大小写</a><span style="color:#666"> [js, python]</span></li></ul></div></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"string","fullPath":"/data-type/string","asPath":"/data-type/string","id":"%2Fdata-type%2Fstring","parent":{"name":"data-type","fullPath":"/data-type","asPath":"/data-type","id":"%2Fdata-type","readme":{"title":"数据类型","fullPath":"/data-type/README.md"}},"readme":{"title":"字符串","fullPath":"/data-type/string/README.md"},"cards":[{"name":"c.md","baseName":"c","extName":".md","fullPath":"/data-type/string/c.md"},{"name":"dart.md","baseName":"dart","extName":".md","fullPath":"/data-type/string/dart.md"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/string/go.md"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/data-type/string/js.md"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/data-type/string/python.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/data-type/string/rust.md"}],"nodes":[{"name":"string-concat","fullPath":"/data-type/string/string-concat","asPath":"/data-type/string/string-concat","id":"%2Fdata-type%2Fstring%2Fstring-concat","parent":{"name":"string","fullPath":"/data-type/string","asPath":"/data-type/string","id":"%2Fdata-type%2Fstring","readme":{"title":"字符串","fullPath":"/data-type/string/README.md"}},"readme":{"title":"字符串拼接","fullPath":"/data-type/string/string-concat/README.md"},"cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/string/string-concat/go.md"}],"nodes":[]},{"name":"string-format","fullPath":"/data-type/string/string-format","asPath":"/data-type/string/string-format","id":"%2Fdata-type%2Fstring%2Fstring-format","parent":{"name":"string","fullPath":"/data-type/string","asPath":"/data-type/string","id":"%2Fdata-type%2Fstring","readme":{"title":"字符串","fullPath":"/data-type/string/README.md"}},"readme":{"title":"格式化输出","fullPath":"/data-type/string/string-format/README.md"},"cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/string/string-format/go.md"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/data-type/string/string-format/js.md"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/data-type/string/string-format/python.md"}],"nodes":[]},{"name":"string-replace","fullPath":"/data-type/string/string-replace","asPath":"/data-type/string/string-replace","id":"%2Fdata-type%2Fstring%2Fstring-replace","parent":{"name":"string","fullPath":"/data-type/string","asPath":"/data-type/string","id":"%2Fdata-type%2Fstring","readme":{"title":"字符串","fullPath":"/data-type/string/README.md"}},"readme":{"title":"字符串替换","fullPath":"/data-type/string/string-replace/README.md"},"cards":[{"name":"dart.md","baseName":"dart","extName":".md","fullPath":"/data-type/string/string-replace/dart.md"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/data-type/string/string-replace/js.md"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/data-type/string/string-replace/python.md"}],"nodes":[]},{"name":"string-search","fullPath":"/data-type/string/string-search","asPath":"/data-type/string/string-search","id":"%2Fdata-type%2Fstring%2Fstring-search","parent":{"name":"string","fullPath":"/data-type/string","asPath":"/data-type/string","id":"%2Fdata-type%2Fstring","readme":{"title":"字符串","fullPath":"/data-type/string/README.md"}},"readme":{"title":"字符串查找","fullPath":"/data-type/string/string-search/README.md"},"cards":[{"name":"dart.md","baseName":"dart","extName":".md","fullPath":"/data-type/string/string-search/dart.md"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/string/string-search/go.md"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/data-type/string/string-search/js.md"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/data-type/string/string-search/python.md"}],"nodes":[]},{"name":"string-sub","fullPath":"/data-type/string/string-sub","asPath":"/data-type/string/string-sub","id":"%2Fdata-type%2Fstring%2Fstring-sub","parent":{"name":"string","fullPath":"/data-type/string","asPath":"/data-type/string","id":"%2Fdata-type%2Fstring","readme":{"title":"字符串","fullPath":"/data-type/string/README.md"}},"readme":{"title":"字符串切割截取","fullPath":"/data-type/string/string-sub/README.md"},"cards":[{"name":"dart.md","baseName":"dart","extName":".md","fullPath":"/data-type/string/string-sub/dart.md"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/data-type/string/string-sub/js.md"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/data-type/string/string-sub/python.md"}],"nodes":[]},{"name":"string-templates","fullPath":"/data-type/string/string-templates","asPath":"/data-type/string/string-templates","id":"%2Fdata-type%2Fstring%2Fstring-templates","parent":{"name":"string","fullPath":"/data-type/string","asPath":"/data-type/string","id":"%2Fdata-type%2Fstring","readme":{"title":"字符串","fullPath":"/data-type/string/README.md"}},"readme":{"title":"文本模板","fullPath":"/data-type/string/string-templates/README.md"},"cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/string/string-templates/go.md"}],"nodes":[]},{"name":"string-uppercase","fullPath":"/data-type/string/string-uppercase","asPath":"/data-type/string/string-uppercase","id":"%2Fdata-type%2Fstring%2Fstring-uppercase","parent":{"name":"string","fullPath":"/data-type/string","asPath":"/data-type/string","id":"%2Fdata-type%2Fstring","readme":{"title":"字符串","fullPath":"/data-type/string/README.md"}},"readme":{"title":"字符串大小写","fullPath":"/data-type/string/string-uppercase/README.md"},"cards":[{"name":"js.md","baseName":"js","extName":".md","fullPath":"/data-type/string/string-uppercase/js.md"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/data-type/string/string-uppercase/python.md"}],"nodes":[]}]},"content":"","cards":[{"name":"c.md","baseName":"c","extName":".md","fullPath":"/data-type/string/c.md","content":"所有字符串的最后一个字符，都是`\\0`\n\n```c++\n// 声明了一个10个成员的字符数组，可以当作字符串。\n// 由于必须留一个位置给\\0，所以最多只能容纳9个字符的字符串。\nchar localString[10];\n\n// C 语言提供了一种简写法，双引号之中的字符，会被自动视为字符数组。\n// 不用自己添加结尾字符\\0，C 语言会自动添加\n{'H', 'e', 'l', 'l', 'o', '\\0'}\n// 等价于\n\"Hello\"\n\n\nchar greeting[50] = \"Hello, \"\"how are you \"\"today!\";\n// 等同于\nchar greeting[50] = \"Hello, how are you today!\";\n// 等同于\nchar greeting[50] = \"Hello, \"\n  \"how are you \"\n  \"today!\";\n\n// 使用占位符%s输出字符串。\nprintf(\"%s\\n\", \"hello world\")\n```\n\n## 字符串变量的声明\n\n```c++\n// 写法一\nchar s[14] = \"Hello, world!\";\nchar s[] = \"Hello, world!\"; // 省略字符数组的长度\n\n// 写法二\nchar* s = \"Hello, world!\";\nconst char* s = \"Hello, world!\";\n```\n\n- 指针指向的字符串，在 C 语言内部被当作常量，不能修改字符串本身。\n\n```c++\nchar* s = \"Hello, world!\";\ns[0] = 'z'; // 错误\n\nchar s[] = \"Hello, world!\";\ns[0] = 'z';\n```\n\n- 指针变量可以指向其它字符串。\n- 但是，字符数组变量不能指向另一个字符串。\n- 编译器一旦为数组变量分配地址后，这个地址就绑定这个数组变量了，这种绑定关系是不变的。\n- 想要重新赋值，必须使用 C 语言原生提供的`strcpy()`函数，通过字符串拷贝完成赋值。\n\n```c++\nchar* s = \"hello\";\ns = \"world\";\n\nchar s[] = \"hello\";\ns = \"world\"; // 报错\n\nchar s[10];\ns = \"abc\"; // 错误\n\nchar s[10];\nstrcpy(s, \"abc\");\n```\n\n## 相关函数\n\n### `strlen()`\n\n```c++\n// strlen()函数返回字符串的字节长度，不包括末尾的空字符\\0。该函数的原型如下。\n// string.h\nsize_t strlen(const char* s);\n\n\n// 返回的是size_t类型的无符号整数，除非是极长的字符串，一般情况下当作int类型处理即可。\nchar* str = \"hello\";\nint len = strlen(str); // 5\n```\n\n```c++\n#include \u003cstdio.h\u003e\n#include \u003cstring.h\u003e\nint main(void) {\n  char* s = \"Hello, world!\";\n  printf(\"The string is %zd characters long.\\n\", strlen(s));\n}\n```\n\n```c++\nchar s[50] = \"hello\";\nprintf(\"%d\\n\", strlen(s));  // 5\nprintf(\"%d\\n\", sizeof(s));  // 50\n```\n\n```c++\n// 自己计算字符串长度。\nint my_strlen(char *s) {\n  int count = 0;\n  while (s[count] != '\\0')\n    count++;\n  return count;\n}\n```\n\n### `strcpy()`\n\n```c++\nchar str1[10];\nchar str2[10];\nstr1 = \"abc\"; // 报错\nstr2 = str1;  // 报错\n\n\n// 结果是两个指针变量s1和s2指向同一字符串，而不是将字符串s1的内容复制给s2\nchar* s1;\nchar* s2;\ns1 = \"abc\";\ns2 = s1;\n```\n\n```c++\n// string.h\n// 必须要保证第一个参数的长度不小于第二个参数，\n// 否则虽然不会报错，但会溢出第一个字符串变量的边界，发生难以预料的结果。\n// 第二个参数的const说明符，表示这个函数不会修改第二个字符串。\nstrcpy(char dest[], const char source[])\n```\n\n```c++\n#include \u003cstdio.h\u003e\n#include \u003cstring.h\u003e\n\nint main(void) {\n  char s[] = \"Hello, world!\";\n  char t[100];\n\n  strcpy(t, s);\n\n  t[0] = 'z';\n  printf(\"%s\\n\", s);  // \"Hello, world!\"\n  printf(\"%s\\n\", t);  // \"zello, world!\"\n}\n```\n\n`strcpy()`的返回值是一个字符串指针（即`char*`），指向第一个参数。\n\n```c++\nchar* s1 = \"beast\";\nchar s2[40] = \"Be the best that you can be.\";\nchar* ps;\n\n// 从s2的第7个位置开始拷贝字符串beast，前面的位置不变\n// s2后面的内容都被截去了，因为会连beast结尾的空字符一起拷贝\nps = strcpy(s2 + 7, s1);\n\nputs(s2); // Be the beast\nputs(ps); // beast\n```\n\n```c++\n// 连续为多个字符数组赋值。\nstrcpy(str1, strcpy(str2, \"abcd\"));\n```\n\n```c++\n// 自己实现字符串的拷贝\nchar* strcpy(char* dest, const char* source) {\n  char* ptr = dest;\n  // 依次将source的每个字符赋值给dest，然后移向下一个位置，直到遇到\\0\n  // *dest++这个表达式等同于*(dest++)，即先返回dest这个地址，再进行自增运算移向下一个位置，\n  // 而*dest可以对当前位置赋值。\n  while (*dest++ = *source++);\n  return ptr;\n}\n\nint main(void) {\n  char str[25];\n  strcpy(str, \"hello world\");\n  printf(\"%s\\n\", str);\n  return 0;\n}\n```\n\n### `strncpy()`\n\n```c++\nstrncpy(str1, str2, sizeof(str1) - 1);\nstr1[sizeof(str1) - 1] = '\\0'; // strncpy()不会自己添加\\0\n```\n\n### `strcat()`\n\n```c++\n// string.h\n// 函数会改变第一个字符串，但是第二个字符串不变\nchar* strcat(char* s1, const char* s2);\n```\n\n```c++\nchar s1[12] = \"hello\";\nchar s2[6] = \"world\";\n\nstrcat(s1, s2);\nputs(s1); // \"helloworld\"\n```\n\n### `strncat()`\n\n```c++\nchar* strncat(\n  const char* dest,\n  const char* src,\n  size_t n\n);\n```\n\n```c++\n// strncat()总是会在拼接结果的结尾，自动添加空字符\\0\n// 通常会写成下面这样\nstrncat(\n  str1,\n  str2,\n  sizeof(str1) - strlen(str1) - 1\n);\n```\n\n### `strcmp()`\n\n`strcmp()`只用来比较字符串，不用来比较字符。\n因为字符就是小整数，直接用相等运算符（`==`）就能比较。\n\n```c++\n// s1 = Happy New Year\n// s2 = Happy New Year\n// s3 = Happy Holidays\n\nstrcmp(s1, s2) // 0\nstrcmp(s1, s3) // 大于 0\nstrcmp(s3, s1) // 小于 0\n```\n\n### `strncmp()`\n\n```c++\nchar s1[12] = \"hello world\";\nchar s2[12] = \"hello C\";\n\nif (strncmp(s1, s2, 5) == 0) {\n  printf(\"They all have hello.\\n\");\n}\n```\n\n### `sprintf()`，`snprintf()`\n\n用于将数据写入字符串，而不是输出到显示器。\n\n```c++\nint sprintf(char* s, const char* format, ...);\nint snprintf(char*s, size_t n, const char* format, ...);\n```\n\n```c++\nchar first[6] = \"hello\";\nchar last[6] = \"world\";\nchar s[40];\n\nsprintf(s, \"%s %s\", first, last);\nprintf(\"%s\\n\", s); // hello world\n```\n\n```c++\n// 表示写入字符串的最大长度不超过12（包括尾部的空字符）\nsnprintf(s, 12, \"%s %s\", \"hello\", \"world\");\n```\n\n## 字符串数组\n\n```c++\nchar weekdays[7][10] = {\n  \"Monday\",\n  \"Tuesday\",\n  \"Wednesday\",\n  \"Thursday\",\n  \"Friday\",\n  \"Saturday\",\n  \"Sunday\"\n};\n\n// 因为第一维的长度，编译器可以自动计算，所以可以省略。\nchar weekdays[][10] = {\n  \"Monday\",\n  \"Tuesday\",\n  \"Wednesday\",\n  \"Thursday\",\n  \"Friday\",\n  \"Saturday\",\n  \"Sunday\"\n};\n\n// 把数组的第二维，从字符数组改成字符指针\n// 其实是一个一维数组，成员就是7个字符指针，每个指针指向一个字符串（字符数组）\nchar* weekdays[] = {\n  \"Monday\",\n  \"Tuesday\",\n  \"Wednesday\",\n  \"Thursday\",\n  \"Friday\",\n  \"Saturday\",\n  \"Sunday\"\n};\n\n// 遍历字符串数组\nfor (int i = 0; i \u003c 7; i++) {\n  printf(\"%s\\n\", weekdays[i]);\n}\n```\n"},{"name":"dart.md","baseName":"dart","extName":".md","fullPath":"/data-type/string/dart.md","content":"Dart 字符串是 UTF-16 编码的字符序列。\n可以使用单引号或者双引号来创建字符串：\n\n```dart\nvar s1 = 'Single quotes work well for string literals.';\nvar s2 = \"Double quotes work just as well.\";\nvar s3 = 'It\\'s easy to escape the string delimiter.';\nvar s4 = \"It's even easier to use the other delimiter.\";\n```\n\n使用三个单引号或者双引号也可以 创建多行字符串对象：\n\n```dart\nvar s1 = '''\nYou can create\nmulti-line strings like this one.\n''';\n\nvar s2 = \"\"\"This is also a\nmulti-line string.\"\"\";\n```\n\n```dart\nvar s = r\"In a raw string, even \\n isn't special.\";\n```\n"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/string/go.md","content":"Go 中的字符串都是采用 UTF-8 字符集编码。\n字符串是用一对双引号（\"\"）或反引号（`` ）括起来定义\n\n```go\nvar frenchHello string  // 声明变量为字符串的一般方法\nvar emptyString string = \"\"  // 声明了一个字符串变量，初始化为空字符串\nfunc test() {\n  no, yes, maybe := \"no\", \"yes\", \"maybe\"  // 简短声明，同时声明多个变量\n  japaneseHello := \"Konichiwa\"  // 同上\n  frenchHello = \"Bonjour\"  // 常规赋值\n}\n\n\n// Go中字符串是不可变的\nvar s string = \"hello\"\ns[0] = 'c' // 出错！！！！\n\ns := \"hello\"\nc := []byte(s)  // 将字符串 s 转换为 []byte 类型\nc[0] = 'c'\ns2 := string(c)  // 再转换回 string 类型\nfmt.Printf(\"%s\\n\", s2)\n```\n\n```go\n// `` 括起的字符串为Raw字符串，\n// 即字符串在代码中的形式就是打印时的形式，\n// 它没有字符转义，换行也将原样输出\nm := `hello\n  world`\n```\n\n```go\npackage main\nimport (\n    \"fmt\"\n    s \"strings\"\n)\nvar p = fmt.Println\nfunc main() {\n    p(\"Contains:  \", s.Contains(\"test\", \"es\"))\n    p(\"Count:     \", s.Count(\"test\", \"t\"))\n    p(\"HasPrefix: \", s.HasPrefix(\"test\", \"te\"))\n    p(\"HasSuffix: \", s.HasSuffix(\"test\", \"st\"))\n    p(\"Index:     \", s.Index(\"test\", \"e\"))\n    p(\"Join:      \", s.Join([]string{\"a\", \"b\"}, \"-\"))\n    p(\"Repeat:    \", s.Repeat(\"a\", 5))\n    p(\"Replace:   \", s.Replace(\"foo\", \"o\", \"0\", -1))\n    p(\"Replace:   \", s.Replace(\"foo\", \"o\", \"0\", 1))\n    p(\"Split:     \", s.Split(\"a-b-c-d-e\", \"-\"))\n    p(\"ToLower:   \", s.ToLower(\"TEST\"))\n    p(\"ToUpper:   \", s.ToUpper(\"test\"))\n    p(\"Len: \", len(\"hello\"))\n    p(\"Char:\", \"hello\"[1])\n}\n\n// Contains:   true\n// Count:      2\n// HasPrefix:  true\n// HasSuffix:  true\n// Index:      1\n// Join:       a-b\n// Repeat:     aaaaa\n// Replace:    f00\n// Replace:    f0o\n// Split:      [a b c d e]\n// ToLower:    test\n// ToUpper:    TEST\n// Len:  5\n// Char: 101\n```\n"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/data-type/string/js.md","content":"```js\nconst x = `------\nLine 1\nLine 2\nLine 3\n------`;\n```\n"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/data-type/string/python.md","content":"```python\nx = \"\"\"------\nLine 1\nLine 2\nLine 3\n------\"\"\"\n\nprint(\"\"\"\\\nUsage: thingy [OPTIONS]\n     -h                        Display this usage message\n     -H hostname               Hostname to connect to\n\"\"\")\n\ntext = ('Put several strings within parentheses '\n        'to have them joined together.')\n```\n\n```python\nsome_string = \"abcd\"\n# 4\nprint(len(some_string))\n\n'spam eggs'  # single quotes\n'doesn\\'t'  # use \\' to escape the single quote...\n\"doesn't\"  # ...or use double quotes instead\n'\"Yes,\" they said.'\n\"\\\"Yes,\\\" they said.\"\n'\"Isn\\'t,\" they said.'\n\nprint('C:\\some\\name')  # here \\n means newline!\nprint(r'C:\\some\\name')  # note the r before the quote\n\n# 字符串可以用 + 进行连接（粘到一起），也可以用 * 进行重复:\n# 3 times 'un', followed by 'ium'\n3 * 'un' + 'ium'\n\n# 相邻的两个或多个 字符串字面值 （引号引起来的字符）将会自动连接到一起.\n'Py' 'thon'\n```\n\n```sh\n# 字符串是可以被 索引 （下标访问）的，第一个字符索引是 0。\n\u003e\u003e\u003e word = 'Python'\n\u003e\u003e\u003e word[0]  # character in position 0\n'P'\n\u003e\u003e\u003e word[5]  # character in position 5\n'n'\n\n# 索引也可以用负数，这种会从右边开始数:\n\u003e\u003e\u003e word[-1]  # last character\n'n'\n\u003e\u003e\u003e word[-2]  # second-last character\n'o'\n\u003e\u003e\u003e word[-6]\n'P'\n\n# 除了索引，字符串还支持 切片。\n\u003e\u003e\u003e word[0:2]  # characters from position 0 (included) to 2 (excluded)\n'Py'\n\u003e\u003e\u003e word[2:5]  # characters from position 2 (included) to 5 (excluded)\n'tho'\n\u003e\u003e\u003e word[:2] + word[2:]\n'Python'\n\u003e\u003e\u003e word[:4] + word[4:]\n'Python'\n```\n\n```python\nprint(r'C:\\some\\name')  # note the r before the quote\n```\n"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/data-type/string/rust.md","content":"- 字节 byte（`u8`）\n- 字符 character（`char`）\n  - 含一个或多个字节\n- 字形簇（字母）\n- 字符串 string（`String`）\n  - `String` 是 `string` 的一种类型\n  - 类似还有 `OsString`, `OsStr`, `CString`, and `CStr`\n  - `String` 被存储为由字节组成的 `vector`（`Vec\u003cu8\u003e`），但保证了它一定是一个有效的 `UTF-8` 序列。\n- 字符串切片 string slice (`\u0026str`)\n  - string slice 是 `String` 中一部分值的引用\n  - 通常是借用的形式 `\u0026str`\n  - `str` 是一个 `DST`；直到运行时我们都不知道字符串有多长。\n  - `\u0026str` 是一个总是指向有效 `UTF-8` 序列的切片（`\u0026[u8]`）\n\n## 创建 String\n\n```rust\n// 新建一个空的 String\nlet mut s = String::new();\n\n// 使用 String::from 函数从字符串字面量创建 String\nlet mut s = String::from(\"hello\");\n\n// 使用 to_string 方法创建 String\n// 这里data的类型是 \u0026str 而不是 str\nlet data = \"initial contents\";\nlet s = data.to_string();\n\n// 该方法也可直接用于字符串字面量：\nlet s = \"initial contents\".to_string();\n```\n\n## 更新 String\n\n```rust\n// 使用 push_str 方法向 String 附加字符串 slice\nlet mut s = String::from(\"foo\");\ns.push_str(\"bar\");\n\n// push_str 不会获取所有权\nlet mut s1 = String::from(\"foo\");\nlet s2 = \"bar\";\ns1.push_str(s2);\nprintln!(\"s2 is {}\", s2);\n\n// 使用 push 将单个字符加入 String 值中\nlet mut s = String::from(\"lo\");\ns.push('l');\n\n// 使用 + 运算符或 format! 宏拼接 String\nlet s1 = String::from(\"Hello, \");\nlet s2 = String::from(\"world!\");\n// 不需要 s2 的所有权，所以加上 \u0026\n// 并且 \u0026String 类型被强转成 \u0026str，即 \u0026s2 被转成 \u0026s2[..]\nlet s3 = s1 + \u0026s2; // 注意 s1 被移动了，不能继续使用\n// 因为 add 没有获取参数的所有权，所以 s2 在这个操作后仍然是有效的 String\n```\n\n`+` 的定义类似\n\n```rust\nlet s3 = s1 + \u0026s2;\n\nfn add(self, s: \u0026str) -\u003e String {\n```\n\n- `\u0026String` 可以被 强转（coerced）成 `\u0026str`\n- 可以发现签名中 `add` 获取了 `self` 的所有权，因为 `self` 没有 使用 `\u0026`。\n- 这意味着 `s1` 的所有权将被移动到 `add` 调用中，之后就不再有效。\n- 实际上这个语句会获取 `s1` 的所有权，附加上从 `s2` 中拷贝的内容，并返回结果的所有权。\n\n```rust\nlet s1 = String::from(\"tic\");\nlet s2 = String::from(\"tac\");\nlet s3 = String::from(\"toe\");\n\nlet s = s1 + \"-\" + \u0026s2 + \"-\" + \u0026s3;\nlet s = format!(\"{}-{}-{}\", s1, s2, s3); // 使用 format! 宏\n```\n\n```rust\nfn first_word(s: \u0026str) -\u003e \u0026str {\n    let bytes = s.as_bytes();\n\n    for (i, \u0026item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return \u0026s[0..i];\n        }\n    }\n\n    \u0026s[..]\n}\n\nfn main() {\n    let my_string = String::from(\"hello world\");\n\n    // `first_word` 接受 `String` 的切片，无论是部分还是全部\n    let word = first_word(\u0026my_string[0..6]);\n    let word = first_word(\u0026my_string[..]);\n    // `first_word` 也接受 `String` 的引用，\n    // 这等同于 `String` 的全部切片\n    let word = first_word(\u0026my_string);\n\n    let my_string_literal = \"hello world\";\n\n    // `first_word` 接受字符串字面量的切片，无论是部分还是全部\n    let word = first_word(\u0026my_string_literal[0..6]);\n    let word = first_word(\u0026my_string_literal[..]);\n\n    // 因为字符串字面值**就是**字符串 slice，\n    // 这样写也可以，即不使用 slice 语法！\n    let word = first_word(my_string_literal);\n}\n```\n\n```rust\nlet s = \"hello world\"; // 这里 s 的类型是 \u0026str，\u0026str 是一个不可变引用\nlet word = first_word(\u0026s[0..6]);  // 这里 word 的类型也是 \u0026str\n\nlet a = [1, 2, 3, 4, 5];\nlet slice = \u0026a[1..3]; // 这个 slice 的类型是 \u0026[i32]\n```\n\n## 索引 String\n\nRust 的字符串不支持索引。\n\n```rust\nlet s1 = String::from(\"hello\");\nlet h = s1[0]; // 错误\n```\n\n```rust\nlet len = String::from(\"Hola\").len();         // 4\nlet len = String::from(\"Здравствуйте\").len(); // 24\n\nlet hello = \"Здравствуйте\";\nlet s = \u0026hello[0..4]; // Зд\n\u0026hello[0..1] // panic\n```\n\n## 遍历 String 的方法\n\n```rust\nfor c in \"नमस्ते\".chars() {\n    println!(\"{}\", c);\n}\n\n// 这些代码会打印出组成 String 的 18 个字节：\nfor b in \"नमस्ते\".bytes() {\n    println!(\"{}\", b);\n}\n```\n\n## 转义\n\n```rust\nfn main() {\n    // 通过转义，可以用十六进制值来表示字节。\n    let byte_escape = \"I'm writing \\x52\\x75\\x73\\x74!\";\n    println!(\"What are you doing\\x3F (\\\\x3F means ?) {}\", byte_escape);\n\n    // 也可以使用 Unicode 码位表示。\n    let unicode_codepoint = \"\\u{211D}\";\n    let character_name = \"\\\"DOUBLE-STRUCK CAPITAL R\\\"\";\n\n    println!(\"Unicode character {} (U+211D) is called {}\",\n                unicode_codepoint, character_name );\n\n\n    let long_string = \"String literals\n                        can span multiple lines.\n                        The linebreak and indentation here -\u003e\\\n                        \u003c- can be escaped too!\";\n    println!(\"{}\", long_string);\n}\n\nfn main() {\n    let raw_str = r\"Escapes don't work here: \\x3F \\u{211D}\";\n    println!(\"{}\", raw_str);\n\n    // 如果你要在原始字符串中写引号，请在两边加一对 #\n    let quotes = r#\"And then I said: \"There is no escape!\"\"#;\n    println!(\"{}\", quotes);\n\n    // 如果字符串中需要写 \"#，那就在定界符中使用更多的 #。\n    // 可使用的 # 的数目没有限制。\n    let longer_delimiter = r###\"A string with \"# in it. And even \"##!\"###;\n    println!(\"{}\", longer_delimiter);\n}\n```\n\n## 非 UTF-8 字符串\n\n```rust\nuse std::str;\n\nfn main() {\n    // 注意这并不是一个 \u0026str\n    let bytestring: \u0026[u8; 20] = b\"this is a bytestring\";\n\n    // 字节串没有实现 Display，所以它们的打印功能有些受限\n    println!(\"A bytestring: {:?}\", bytestring);\n\n    // 字节串可以使用单字节的转义字符...\n    let escaped = b\"\\x52\\x75\\x73\\x74 as bytes\";\n    // ...但不能使用 Unicode 转义字符\n    // let escaped = b\"\\u{211D} is not allowed\";\n    println!(\"Some escaped bytes: {:?}\", escaped);\n\n\n    // 原始字节串和原始字符串的写法一样\n    let raw_bytestring = br\"\\u{211D} is not escaped here\";\n    println!(\"{:?}\", raw_bytestring);\n\n    // 把字节串转换为 \u0026str 可能失败\n    if let Ok(my_str) = str::from_utf8(raw_bytestring) {\n        println!(\"And the same as text: '{}'\", my_str);\n    }\n\n    let quotes = br#\"You can also use \"fancier\" formatting, \\\n                    like with normal raw strings\"#;\n\n    // 字节串可以不使用 UTF-8 编码\n    let shift_jis = b\"\\x82\\xe6\\x82\\xa8\\x82\\xb1\\x82\"; // SHIFT-JIS 编码的 \"ようこそ\"\n\n    // 但这样的话它们就无法转换成 \u0026str 了\n    match str::from_utf8(shift_jis) {\n        Ok(my_str) =\u003e println!(\"Conversion successful: '{}'\", my_str),\n        Err(e) =\u003e println!(\"Conversion failed: {:?}\", e),\n    };\n}\n```\n"}]}},"page":"/[...param]","query":{"param":["data-type","string"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"字符串"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>