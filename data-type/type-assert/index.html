<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>数据类型判断</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>数据类型判断</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="dart" autoComplete="off"/>dart</label><label class="btn btn-secondary"><input type="checkbox" value="go" autoComplete="off"/>go</label><label class="btn btn-secondary"><input type="checkbox" value="js" autoComplete="off"/>js</label><label class="btn btn-secondary"><input type="checkbox" value="python" autoComplete="off"/>python</label></div></div></div></div><div class="card-group"></div><div style="margin-top:12px" class="card"><div class="card-body"><h6>了解更多</h6><ul><li><a href="/comparison-note/data-type/type-assert/check-if-the-same-object/">检查两个引用是否指向同一个对象(内存地址)</a><span style="color:#666"> [dart, js]</span></li><li><a href="/comparison-note/data-type/type-assert/deep-equal/">深度比较</a><span style="color:#666"> [go]</span></li></ul></div></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"type-assert","fullPath":"/data-type/type-assert","asPath":"/data-type/type-assert","id":"%2Fdata-type%2Ftype-assert","parent":{"name":"data-type","fullPath":"/data-type","asPath":"/data-type","id":"%2Fdata-type","readme":{"title":"数据类型","fullPath":"/data-type/README.md"}},"readme":{"title":"数据类型判断","fullPath":"/data-type/type-assert/README.md"},"cards":[{"name":"dart.md","baseName":"dart","extName":".md","fullPath":"/data-type/type-assert/dart.md"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/type-assert/go.md"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/data-type/type-assert/js.md"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/data-type/type-assert/python.md"}],"nodes":[{"name":"check-if-the-same-object","fullPath":"/data-type/type-assert/check-if-the-same-object","asPath":"/data-type/type-assert/check-if-the-same-object","id":"%2Fdata-type%2Ftype-assert%2Fcheck-if-the-same-object","parent":{"name":"type-assert","fullPath":"/data-type/type-assert","asPath":"/data-type/type-assert","id":"%2Fdata-type%2Ftype-assert","readme":{"title":"数据类型判断","fullPath":"/data-type/type-assert/README.md"}},"readme":{"title":"检查两个引用是否指向同一个对象(内存地址)","fullPath":"/data-type/type-assert/check-if-the-same-object/README.md"},"cards":[{"name":"dart.md","baseName":"dart","extName":".md","fullPath":"/data-type/type-assert/check-if-the-same-object/dart.md"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/data-type/type-assert/check-if-the-same-object/js.md"}],"nodes":[]},{"name":"deep-equal","fullPath":"/data-type/type-assert/deep-equal","asPath":"/data-type/type-assert/deep-equal","id":"%2Fdata-type%2Ftype-assert%2Fdeep-equal","parent":{"name":"type-assert","fullPath":"/data-type/type-assert","asPath":"/data-type/type-assert","id":"%2Fdata-type%2Ftype-assert","readme":{"title":"数据类型判断","fullPath":"/data-type/type-assert/README.md"}},"readme":{"title":"深度比较","fullPath":"/data-type/type-assert/deep-equal/README.md"},"cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/type-assert/deep-equal/go.md"}],"nodes":[]}]},"content":"","cards":[{"name":"dart.md","baseName":"dart","extName":".md","fullPath":"/data-type/type-assert/dart.md","content":"```dart\n// as 类型转换\n// is 如果对象是指定的类型返回 True\n// is! 如果对象是指定的类型返回 False\n\nif (emp is Person) { // Type check\n  emp.firstName = 'Bob';\n}\n// 使用 as 操作符可以简化上面的代码：\n(emp as Person).firstName = 'Bob';\n\n// 可以使用 Object 的 runtimeType 属性来判断实例 的类型，\n// 该属性 返回一个 Type 对象。\nvar msg = 'false';\nprint('The type of a is ${msg.runtimeType}');\n\n// 其他方式\nimport 'dart:mirrors';\ngetTypeName(dynamic obj) {\n  return reflect(obj).type.reflectedType.toString();\n}\n```\n"},{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/type-assert/go.md","content":"```go\n// reflect.Type 接口是满足 fmt.Stringer 接口的\nt := reflect.TypeOf(3)  // a reflect.Type\nfmt.Println(t.String()) // \"int\"\nfmt.Println(t)          // \"int\"\nfmt.Printf(\"%T\\n\", 3)   // \"int\"\n\n// 表达接口类型的 reflect.Type\nvar w io.Writer = os.Stdout\nfmt.Println(reflect.TypeOf(w)) // \"*os.File\"\n\n\n// fmt.Printf 提供了一个缩写 %T 参数，\n// 内部使用 reflect.TypeOf 来输出\n// 可以通过%T参数打印类型信息\nconst noDelay time.Duration = 0\nconst timeout = 5 * time.Minute\nfmt.Printf(\"%T %[1]v\\n\", noDelay)     // \"time.Duration 0\"\nfmt.Printf(\"%T %[1]v\\n\", timeout)     // \"time.Duration 5m0s\"\nfmt.Printf(\"%T %[1]v\\n\", time.Minute) // \"time.Duration 1m0s\"\n\nfmt.Printf(\"%T\\n\", 0)      // \"int\"\nfmt.Printf(\"%T\\n\", 0.0)    // \"float64\"\nfmt.Printf(\"%T\\n\", 0i)     // \"complex128\"\nfmt.Printf(\"%T\\n\", '\\000') // \"int32\" (rune)\n\n\nvar t interface{}\nt = functionOfSomeType()\nswitch t := t.(type) {\n  default:\n    fmt.Printf(\"unexpected type %T\", t)       // %T 输出 t 是什么类型\n  case bool:\n    fmt.Printf(\"boolean %t\\n\", t)             // t 是 bool 类型\n  case int:\n    fmt.Printf(\"integer %d\\n\", t)             // t 是 int 类型\n  case *bool:\n    fmt.Printf(\"pointer to boolean %t\\n\", *t) // t 是 *bool 类型\n  case *int:\n    fmt.Printf(\"pointer to integer %d\\n\", *t) // t 是 *int 类型\n}\n```\n\n```go\npackage main\nimport (\n  \"fmt\"\n  \"strconv\"\n)\ntype Element interface{}\ntype List [] Element\ntype Person struct {\n    name string\n    age int\n}\n//定义了String方法，实现了fmt.Stringer\nfunc (p Person) String() string {\n  return \"(name: \" + p.name + \" - age: \"+strconv.Itoa(p.age)+ \" years)\"\n}\nfunc main() {\n  list := make(List, 3)\n  list[0] = 1 // an int\n  list[1] = \"Hello\" // a string\n  list[2] = Person{\"Dennis\", 70}\n  // for index, element := range list {\n  //   if value, ok := element.(int); ok {\n  //     fmt.Printf(\"list[%d] is an int and its value is %d\\n\", index, value)\n  //   } else if value, ok := element.(string); ok {\n  //     fmt.Printf(\"list[%d] is a string and its value is %s\\n\", index, value)\n  //   } else if value, ok := element.(Person); ok {\n  //     fmt.Printf(\"list[%d] is a Person and its value is %s\\n\", index, value)\n  //   } else {\n  //     fmt.Printf(\"list[%d] is of a different type\\n\", index)\n  //   }\n  // }\n  for index, element := range list{\n    switch value := element.(type) {\n      case int:\n        fmt.Printf(\"list[%d] is an int and its value is %d\\n\", index, value)\n      case string:\n        fmt.Printf(\"list[%d] is a string and its value is %s\\n\", index, value)\n      case Person:\n        fmt.Printf(\"list[%d] is a Person and its value is %s\\n\", index, value)\n      default:\n        fmt.Println(\"list[%d] is of a different type\", index)\n    }\n  }\n}\n```\n\n使用 `reflect.Type` 来打印任意值的类型和枚举它的方法：\n\n```go\n// Print prints the method set of the value x.\nfunc Print(x interface{}) {\n    v := reflect.ValueOf(x)\n    t := v.Type()\n    fmt.Printf(\"type %s\\n\", t)\n\n    for i := 0; i \u003c v.NumMethod(); i++ {\n        methType := v.Method(i).Type()\n        fmt.Printf(\"func (%s) %s%s\\n\", t, t.Method(i).Name,\n            strings.TrimPrefix(methType.String(), \"func\"))\n    }\n}\n```\n\n## 类型断言\n\n类型断言书写形式如下：\n\n```go\nx.(T)\n```\n\n`x` 必须是接口（类型的）值，注意不是接口名。\n\n换一个角度说，`x`必须是被接口类型隐式转换过，其原类型（底层类型）可能是接口类型，也可能不是接口类型，甚至也可能是`nil`。\n当然，前提是原类型（底层类型）实现了该接口，才能被赋值（转换）。\n\n```go\nvar x = 1 // 这里的x不是接口类型的值，不能做类型断言操作\ntype I interface{} // 这里的I是接口名，因此I不能做类型断言操作\nvar x interface{} // 这里的x是值为nil的接口值，可以做类型断言，但是一定会断言失败\nvar x interface{} = \"hello\" // 这里的x可以做类型断言操作\n```\n\n如果对 x（接口类型）进行了非`nil`赋值操作（隐式转换），那这个接口值就获得了`动态类型`（底层类型）和`动态值`（底层值）。\n\n但不管赋值（转换）多少次，在某个时刻，它的`动态类型`和`动态值`都是唯一（最后那次赋值）的。\n\n对`x`做类型断言，也会有赋值（隐式转换）效果。\n\n```go\nvar x interface{} // 相当于给x接口值赋初始值nil，此时没有动态类型和动态值\n\nvar x interface{} = \"hello\" // x的动态类型为string，动态值为hello，相当于下面三行代码的简写\n\ntype I interface{}\nvar s string = \"hello\"\nvar x I = s // 这里有个隐式类型转换，相当于 var x = I(s)\n```\n\n`T` 必须是数据类型名（因为接口也是一种数据类型，因此包含接口名），注意不能是一个具体的值。\n\n```go\nvar i interface{}\nx.(i) // 这里的i非法\n\n// 以下都可以\nx.(int)\nx.(string)\ntype I interface{}\nx.(I)\n```\n\n关于类型断言的真假判断\n\n- 当 T 是普通数据类型名（非接口名），判断 x 的动态类型是否等于 T\n- 当 T 是接口名，判断 x 的动态类型是否实现了 T 接口，即判断 x 的动态类型是否定义了 T 接口规定的方法\n- 同时，由以上可以推断，当 x 为 nil，断言一定失败。因为 nil 不等于任何数据类型，也没有实现任何接口\n\n```go\npackage main\nimport \"fmt\"\n\ntype I interface {\n\tm(string)\n}\ntype II interface {\n\tI\n\tn(string)\n}\ntype III interface {\n\tII\n\to()\n}\n\ntype T string\n\nfunc (t T) m(s string) {\n\tfmt.Println(\"m\", s)\n\t// fmt.Printf(\"%T\\n\", t)\n}\n\nfunc (t T) n(s string) {\n\tfmt.Println(\"n\", s)\n\t// fmt.Printf(\"%T\\n\", t)\n}\n\nfunc main() {\n\tvar x I = T(\"hello\")\n\n  \tif x, ok := x.(T); ok { // 这里判断x的动态类型是否为T\n\t\t// 此时x为一个普通T类型的值，不是接口值\n\t\tx.m(\"1\")\n\t\tx.n(\"2\")\n\t}\n\n\tif x, ok := x.(I); ok { // 这里判断x的动态类型(T)是否实现了I接口\n\t\t// 此时x为I类型的接口值，相当于一个拷贝\n\t\tx.m(\"3\")\n\t\t// x.n(\"4\") // I接口没有n方法\n\t}\n\n\tif x, ok := x.(II); ok { // 这里判断x的动态类型(T)是否实现了II接口\n\t\t// 此时x转换为II类型的接口值\n\t\tx.m(\"5\")\n\t\tx.n(\"6\")\n\t}\n\n  \tif x, ok := x.(III); ok { // 这里判断x的动态类型(T)是否实现了III接口\n\t\tx.m(\"7\")\n\t\tx.n(\"8\")\n\t}\n\n\tvar xx II = T(\"hello\")\n\n\tif x, ok := xx.(T); ok {\n\t\t// 此时x为一个T类型的普通值，\n\t\tx.m(\"9\")\n\t\tx.n(\"a\")\n\t}\n\n\tif x, ok := xx.(I); ok {\n\t\t// x为一个I接口类型的值，相当于xx做了I类型转换\n\t\tx.m(\"b\")\n\t\t// x.n(\"c\") // I接口没有n方法\n\t}\n\n\tif x, ok := xx.(II); ok {\n\t\t// x为一个II类型的值，，相当于xx的一个拷贝\n\t\tx.m(\"d\")\n\t\tx.n(\"e\")\n\t}\n}\n// m 1\n// n 2\n// m 3\n// m 5\n// n 6\n// m 9\n// n a\n// m b\n// m d\n// n e\n```\n\n关于类型断言的值（实质：对`x动态值`做`T类型`转换后的值）\n\n- 只有一个变量接收断言结果时\n  - 当断言失败时，会抛出 panic\n  - 当断言成功时，返回一个 T 类型的值\n    - 当 T 为普通类型名，则返回一个 T 类型的普通值\n    - 当 T 为接口名，则返回一个 T 类型的接口值。\n- 有两个变量接收断言结果时，不管成功失败都不会抛出 panic\n  - 当断言失败时，第一个变量为 T 类型的零值，第二个变量为 false\n  - 当断言成功时，第一个变量为 T 类型的转换值（同一个变量成功时的返回值），第二个变量为 true\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype I interface {\n\tM()\n}\n\ntype T string\n\nfunc (t T) M() {\n\tfmt.Println(t)\n}\n\nfunc main() {\n\tvar i I = T(\"hello\")\n\tif x, ok := i.(I); ok {\n\t\t// 此时，x为一个I接口值，可以继续做类型断言\n\t\tx.M()\n\t\tif y, ok := x.(T); ok {\n\t\t\t// 此时，y为一个T类型值，不能再做类型断言\n\t\t\ty.M()\n\t\t}\n\t}\n}\n```\n\n特例：当 T 为保留关键字`type`时，可以用在`switch`语句中，用来做类型判断\n\n```go\nswitch i := x.(type) { // 这里的赋值语句有点奇怪，语句本身还可以产生一个结果值，这个结果值是x的动态类型\ncase nil:\n\tprintString(\"x is nil\")                // type of i is type of x (interface{})\ncase int:\n\tprintInt(i)                            // type of i is int\ncase float64:\n\tprintFloat64(i)                        // type of i is float64\ncase func(int) float64:\n\tprintFunction(i)                       // type of i is func(int) float64\ncase bool, string:\n\tprintString(\"type is bool or string\")  // type of i is type of x (interface{})\ndefault:\n\tprintString(\"don't know the type\")     // type of i is type of x (interface{})\n}\n```\n"},{"name":"js.md","baseName":"js","extName":".md","fullPath":"/data-type/type-assert/js.md","content":"```js\ntypeof undefined; // undefined\ntypeof []; // object\ntypeof \"123\"; // string\ntypeof null; // object\n\n// instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。\nconst s = new String(\"123\");\ns instanceof String; // true\ns instanceof Object; // true\n\nv instanceof Vehicle;\n// 等同于\nVehicle.prototype.isPrototypeOf(v);\n\nObject.prototype.toString.call(2); // \"[object Number]\"\nObject.prototype.toString.call(\"\"); // \"[object String]\"\nObject.prototype.toString.call(true); // \"[object Boolean]\"\nObject.prototype.toString.call(undefined); // \"[object Undefined]\"\nObject.prototype.toString.call(null); // \"[object Null]\"\nObject.prototype.toString.call(Math); // \"[object Math]\"\nObject.prototype.toString.call({}); // \"[object Object]\"\nObject.prototype.toString.call([]); // \"[object Array]\"\n\nvar type = function(o) {\n  var s = Object.prototype.toString.call(o);\n  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();\n};\ntype({}); // \"object\"\ntype([]); // \"array\"\ntype(5); // \"number\"\ntype(null); // \"null\"\ntype(); // \"undefined\"\ntype(/abcd/); // \"regex\"\ntype(new Date()); // \"date\"\n\n[\n  \"Null\",\n  \"Undefined\",\n  \"Object\",\n  \"Array\",\n  \"String\",\n  \"Number\",\n  \"Boolean\",\n  \"Function\",\n  \"RegExp\",\n].forEach(function(t) {\n  type[\"is\" + t] = function(o) {\n    return type(o) === t.toLowerCase();\n  };\n});\ntype.isObject({}); // true\ntype.isNumber(NaN); // true\ntype.isRegExp(/abc/); // true\n\nfunction type(obj) {\n  return Reflect.apply(Object.prototype.toString, obj, [])\n    .replace(/^\\[object\\s(\\w+)\\]$/, \"$1\")\n    .toLowerCase();\n}\ntype(new String(\"123\")); // string\n```\n"},{"name":"python.md","baseName":"python","extName":".md","fullPath":"/data-type/type-assert/python.md","content":"```python\nimport types\ntype(myInt) is types.IntType\ntype(myInt) is type(1)\nisinstance(myInt, int)\n```\n"}]}},"page":"/[...param]","query":{"param":["data-type","type-assert"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"数据类型判断"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>