<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>接口/特征（interface/trait）</title><link rel="preload" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/dc4eece8d63e31b4b040.css" data-n-g=""/><link rel="preload" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" as="style"/><link rel="stylesheet" href="/comparison-note/_next/static/css/05437c60348a21355b6c.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" as="script"/><link rel="preload" href="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" as="script"/></head><body><div id="__next"><nav class="navbar navbar-expand-lg navbar-light bg-light"><a href="/comparison-note/" class="navbar-brand">对比学习笔记</a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="mr-auto navbar-nav"><a href="/comparison-note/algorithm" data-rb-event-key="/algorithm" class="nav-link">数据结构和算法</a><a href="/comparison-note/basic-concept" data-rb-event-key="/basic-concept" class="nav-link">基础概念</a><a href="/comparison-note/data-type" data-rb-event-key="/data-type" class="nav-link">数据类型</a><a href="/comparison-note/special" data-rb-event-key="/special" class="nav-link">专题</a></div></div></nav><div style="padding-top:12px;padding-bottom:12px" class="container-fluid"><h1>接口/特征（interface/trait）</h1><div style="margin-bottom:12px"><div class="markdown-body"></div></div><div style="margin-bottom:12px" class="justify-content-md-center row"><div class="col-md-auto"><div role="toolbar" class="btn-toolbar"><div role="group" class="btn-group btn-group-sm btn-group-toggle"><label class="btn btn-secondary"><input type="checkbox" value="go" autoComplete="off"/>go</label><label class="btn btn-secondary"><input type="checkbox" value="rust" autoComplete="off"/>rust</label></div></div></div></div><div class="card-group"></div></div><div style="text-align:center;padding:12px 0;font-size:14px">v<!-- -->0.1.0<!-- --> <a href="https://github.com/fishjar/comparison-note" title="访问github源码">github</a></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"nav":{"name":"interface","fullPath":"/data-type/interface","asPath":"/data-type/interface","id":"%2Fdata-type%2Finterface","parent":{"name":"data-type","fullPath":"/data-type","asPath":"/data-type","id":"%2Fdata-type","readme":{"title":"数据类型","fullPath":"/data-type/README.md"}},"readme":{"title":"接口/特征（interface/trait）","fullPath":"/data-type/interface/README.md"},"cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/interface/go.md"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/data-type/interface/rust.md"}],"nodes":[]},"content":"","cards":[{"name":"go.md","baseName":"go","extName":".md","fullPath":"/data-type/interface/go.md","content":"# 接口完整性检查\n\n```go\ntype Shape interface {\n    Sides() int\n    Area() int\n}\ntype Square struct {\n    len int\n}\nfunc (s* Square) Sides() int {\n    return 4\n}\nfunc main() {\n    s := Square{len: 5}\n    fmt.Printf(\"%d\\n\",s.Sides())\n}\n\n// 声明一个 _ 变量（没人用），\n// 其会把一个 nil 的空指针，从 Square 转成 Shape，\n// 这样，如果没有实现完相关的接口方法，编译器就会报错\nvar _ Shape = (*Square)(nil)\n```\n"},{"name":"rust.md","baseName":"rust","extName":".md","fullPath":"/data-type/interface/rust.md","content":"## trait\n\n`trait` 类似于其他语言中常被称为 接口（`interfaces`）的功能，虽然有一些不同。\n\n孤儿规则（`orphan rule`）：\n\n实现 `trait` 时需要注意的一个限制是，只有当 `trait` 或者要实现 `trait` 的类型位于 `crate` 的本地作用域时，才能为该类型实现 `trait`。\n\n- 例如，可以为 `aggregator crate` 的自定义类型 `Tweet` 实现如标准库中的 `Display trait`，这是因为 `Tweet` 类型位于 `aggregator crate` 本地的作用域中。\n- 类似地，也可以在 `aggregator crate` 中为`Vec\u003cT\u003e` 实现 `Summary`，这是因为 `Summary trait` 位于 `aggregator crate` 本地作用域中。\n- 不能在 `aggregator crate` 中为 `Vec\u003cT\u003e` 实现 `Display trait`。这是因为 `Display` 和 `Vec\u003cT\u003e` 都定义于标准库中，它们并不位于 `aggregator crate` 本地作用域中。\n\n```rust\n// 定义 trait\n// 如果这个 lib.rs 是对应 aggregator crate 的，\n// 别人想要利用我们 crate 的功能为其自己的库作用域中的结构体实现 Summary trait。\n// 首先他们需要将 trait 引入作用域。\n// 这可以通过指定 use aggregator::Summary; 实现\n// Summary 还必须是公有 trait 使得其他 crate 可以实现它\npub trait Summary {\n    fn summarize(\u0026self) -\u003e String;\n}\n\n// 为类型实现 trait\npub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\nimpl Summary for NewsArticle {\n    fn summarize(\u0026self) -\u003e String {\n        format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n    }\n}\n\n// 为类型实现 trait\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\nimpl Summary for Tweet {\n    fn summarize(\u0026self) -\u003e String {\n        format!(\"{}: {}\", self.username, self.content)\n    }\n}\n\n// 调用 trait 方法\nlet tweet = Tweet {\n    username: String::from(\"horse_ebooks\"),\n    content: String::from(\"of course, as you probably already know, people\"),\n    reply: false,\n    retweet: false,\n};\nprintln!(\"1 new tweet: {}\", tweet.summarize());\n```\n\n## 默认实现\n\n```rust\n// Summary trait 的定义，带有一个 summarize 方法的默认实现\npub trait Summary {\n    fn summarize(\u0026self) -\u003e String {\n        String::from(\"(Read more...)\")\n    }\n}\nimpl Summary for NewsArticle {}\n```\n\n```rust\npub trait Summary {\n    fn summarize_author(\u0026self) -\u003e String;\n    fn summarize(\u0026self) -\u003e String {\n        format!(\"(Read more from {}...)\", self.summarize_author())\n    }\n}\nimpl Summary for Tweet {\n    // 重载默认实现\n    fn summarize_author(\u0026self) -\u003e String {\n        format!(\"@{}\", self.username)\n    }\n}\n```\n\n## trait 作为参数\n\n```rust\npub fn notify(item: impl Summary) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n// Trait Bound 语法\npub fn notify\u003cT: Summary\u003e(item: T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\n// 只要求实现了Summary\npub fn notify(item1: impl Summary, item2: impl Summary) {}\n// 强制都是相同的具体类型，并且都实现了Summary\npub fn notify\u003cT: Summary\u003e(item1: T, item2: T) {}\n\n// 通过 + 指定多个 trait bound\npub fn notify(item: impl Summary + Display) {}\npub fn notify\u003cT: Summary + Display\u003e(item: T) {}\n\n// 通过 where 简化 trait bound\nfn some_function\u003cT: Display + Clone, U: Clone + Debug\u003e(t: T, u: U) -\u003e i32 {}\nfn some_function\u003cT, U\u003e(t: T, u: U) -\u003e i32\n    where T: Display + Clone,\n          U: Clone + Debug\n{}\n```\n\n## 返回实现了 trait 的类型\n\n```rust\n// 这只适用于返回单一类型的情况。\nfn returns_summarizable() -\u003e impl Summary {\n    Tweet {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\"of course, as you probably already know, people\"),\n        reply: false,\n        retweet: false,\n    }\n}\n```\n\n## 使用 trait bound 有条件地实现方法\n\n```rust\nuse std::fmt::Display;\nstruct Pair\u003cT\u003e {\n    x: T,\n    y: T,\n}\n// 类型 Pair\u003cT\u003e 总是实现了 new 方法\nimpl\u003cT\u003e Pair\u003cT\u003e {\n    fn new(x: T, y: T) -\u003e Self {\n        Self {\n            x,\n            y,\n        }\n    }\n}\n// 不过只有那些为 T 类型实现了 PartialOrd trait （来允许比较） 和 Display trait （来启用打印）\n// 的 Pair\u003cT\u003e 才会实现 cmp_display 方法：\n// 满足特定 trait bound 的类型实现 trait 被称为 blanket implementations\nimpl\u003cT: Display + PartialOrd\u003e Pair\u003cT\u003e {\n    fn cmp_display(\u0026self) {\n        if self.x \u003e= self.y {\n            println!(\"The largest member is x = {}\", self.x);\n        } else {\n            println!(\"The largest member is y = {}\", self.y);\n        }\n    }\n}\n```\n\n## 关联类型在 trait 定义中指定占位符类型\n\n关联类型（associated types）是一个将类型占位符与 trait 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。\n\n```rust\n// Iterator trait 的定义中带有关联类型 Item\n// 这里没有泛型参数 T\n// 我们只能选择一次 Item 会是什么类型\npub trait Iterator {\n    type Item;\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e;\n}\nimpl Iterator for Counter {\n    // 这里指定 trait 定义里面的 Item 的类型\n    type Item = u32;\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {}\n}\n\n// 一个使用泛型的 Iterator trait 假想定义\npub trait Iterator\u003cT\u003e {\n    fn next(\u0026mut self) -\u003e Option\u003cT\u003e;\n}\n```\n\n## 默认泛型类型参数和运算符重载\n\n```rust\n// 实现 Add trait 重载 Point 实例的 + 运算符\nuse std::ops::Add;\n#[derive(Debug, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n// 使用默认 RHS 参数\nimpl Add for Point {\n    // Add trait 有一个叫做 Output 的关联类型，它用来决定 add 方法的返回值类型。\n    type Output = Point;\n    fn add(self, other: Point) -\u003e Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\nfn main() {\n    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n               Point { x: 3, y: 3 });\n}\n```\n\n```rust\n// Add trait 的定义\ntrait Add\u003cRHS=Self\u003e {\n    type Output;\n    fn add(self, rhs: RHS) -\u003e Self::Output;\n}\n```\n\n```rust\n// 在 Millimeters 上实现 Add，以便能够将 Millimeters 与 Meters 相加\nuse std::ops::Add;\nstruct Millimeters(u32);\nstruct Meters(u32);\n// 自定义 RHS 参数\nimpl Add\u003cMeters\u003e for Millimeters {\n    type Output = Millimeters;\n    fn add(self, other: Meters) -\u003e Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n```\n\n## 完全限定语法与消歧义：调用相同名称的方法\n\n```rust\ntrait Pilot {\n    fn fly(\u0026self);\n}\ntrait Wizard {\n    fn fly(\u0026self);\n}\n\nstruct Human;\nimpl Pilot for Human {\n    fn fly(\u0026self) {\n        println!(\"This is your captain speaking.\");\n    }\n}\nimpl Wizard for Human {\n    fn fly(\u0026self) {\n        println!(\"Up!\");\n    }\n}\n\nimpl Human {\n    fn fly(\u0026self) {\n        println!(\"*waving arms furiously*\");\n    }\n}\nfn main() {\n    let person = Human;\n    Pilot::fly(\u0026person);\n    Wizard::fly(\u0026person);\n    person.fly();\n}\n// This is your captain speaking.\n// Up!\n// *waving arms furiously*\n```\n\n```rust\ntrait Animal {\n    fn baby_name() -\u003e String;\n}\nstruct Dog;\nimpl Dog {\n    fn baby_name() -\u003e String {\n        String::from(\"Spot\")\n    }\n}\nimpl Animal for Dog {\n    fn baby_name() -\u003e String {\n        String::from(\"puppy\")\n    }\n}\nfn main() {\n    println!(\"A baby dog is called a {}\", Dog::baby_name());\n    println!(\"A baby dog is called a {}\", \u003cDog as Animal\u003e::baby_name());\n}\n// A baby dog is called a Spot\n// A baby dog is called a puppy\n```\n\n## 父 trait 用于在另一个 trait 中使用某 trait 的功能\n\n```rust\nuse std::fmt;\n// 实现 OutlinePrint trait，它要求来自 Display 的功能\n// 因为指定了 OutlinePrint 需要 Display trait，\n// 则可以在 outline_print 中使用 to_string， 其会为任何实现 Display 的类型自动实现。\ntrait OutlinePrint: fmt::Display {\n    fn outline_print(\u0026self) {\n        let output = self.to_string();\n        let len = output.len();\n        println!(\"{}\", \"*\".repeat(len + 4));\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"* {} *\", output);\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"{}\", \"*\".repeat(len + 4));\n    }\n}\n\n// 如果尝试在一个没有实现 Display 的类型上实现 OutlinePrint 会发生什么，\n// 比如 Point 结构体：\n// 这样会得到一个错误说 Display 是必须的而未被实现：\nstruct Point {\n    x: i32,\n    y: i32,\n}\nimpl OutlinePrint for Point {}\n\n// 一旦在 Point 上实现 Display 并满足 OutlinePrint 要求的限制，\n// 比如这样：将能成功编译\nuse std::fmt;\nimpl fmt::Display for Point {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"({}, {})\", self.x, self.y)\n    }\n}\n```\n\n## newtype 模式用以在外部类型上实现外部 trait\n\n如果想要在 `Vec\u003cT\u003e` 上实现 `Display`，而孤儿规则阻止我们直接这么做，\n因为 `Display trait` 和 `Vec\u003cT\u003e` 都定义于我们的 `crate` 之外。\n可以创建一个包含 `Vec\u003cT\u003e` 实例的 `Wrapper` 结构体，\n接着可以如列表 19-31 那样在 `Wrapper` 上实现 `Display` 并使用 `Vec\u003cT\u003e` 的值：\n\n```rust\nuse std::fmt;\nstruct Wrapper(Vec\u003cString\u003e);\nimpl fmt::Display for Wrapper {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"[{}]\", self.0.join(\", \"))\n    }\n}\n\nfn main() {\n    let w = Wrapper(vec![String::from(\"hello\"), String::from(\"world\")]);\n    println!(\"w = {}\", w);\n}\n```\n\n## 派生\n\n下面是可以自动派生的 trait：\n\n- 比较 trait: `Eq`, `PartialEq`, `Ord`, `PartialOrd`\n- `Clone`, 用来从 `\u0026T` 创建副本 `T`。\n- `Copy`，使类型具有 “复制语义”（copy semantics）而非 “移动语义”（move semantics）。\n- `Hash`，从 `\u0026T` 计算哈希值（hash）。\n- `Default`, 创建数据类型的一个空实例。\n- `Debug`，使用 `{:?}` formatter 来格式化一个值。\n\n## 使用 dyn 返回 trait\n\n```rust\nstruct Sheep {}\nstruct Cow {}\n\ntrait Animal {\n    // 实例方法签名\n    fn noise(\u0026self) -\u003e \u0026'static str;\n}\n\n// 实现 `Sheep` 的 `Animal` trait。\nimpl Animal for Sheep {\n    fn noise(\u0026self) -\u003e \u0026'static str {\n        \"baaaaah!\"\n    }\n}\n\n// 实现 `Cow` 的 `Animal` trait。\nimpl Animal for Cow {\n    fn noise(\u0026self) -\u003e \u0026'static str {\n        \"moooooo!\"\n    }\n}\n\n// 返回一些实现 Animal 的结构体，但是在编译时我们不知道哪个结构体。\nfn random_animal(random_number: f64) -\u003e Box\u003cdyn Animal\u003e {\n    if random_number \u003c 0.5 {\n        Box::new(Sheep {})\n    } else {\n        Box::new(Cow {})\n    }\n}\n\nfn main() {\n    let random_number = 0.234;\n    let animal = random_animal(random_number);\n    println!(\"You've randomly chosen an animal, and it says {}\", animal.noise());\n}\n```\n\n## 运算符重载\n\n```rust\nuse std::ops;\n\nstruct Foo;\nstruct Bar;\n\n#[derive(Debug)]\nstruct FooBar;\n\n#[derive(Debug)]\nstruct BarFoo;\n\n// `std::ops::Add` trait 用来指明 `+` 的功能，这里我们实现 `Add\u003cBar\u003e`，它是用于\n// 把对象和 `Bar` 类型的右操作数（RHS）加起来的 `trait`。\n// 下面的代码块实现了 `Foo + Bar = FooBar` 这样的运算。\nimpl ops::Add\u003cBar\u003e for Foo {\n    type Output = FooBar;\n\n    fn add(self, _rhs: Bar) -\u003e FooBar {\n        println!(\"\u003e Foo.add(Bar) was called\");\n\n        FooBar\n    }\n}\n\n// 通过颠倒类型，我们实现了不服从交换律的加法。\n// 这里我们实现 `Add\u003cFoo\u003e`，它是用于把对象和 `Foo` 类型的右操作数加起来的 trait。\n// 下面的代码块实现了 `Bar + Foo = BarFoo` 这样的运算。\nimpl ops::Add\u003cFoo\u003e for Bar {\n    type Output = BarFoo;\n\n    fn add(self, _rhs: Foo) -\u003e BarFoo {\n        println!(\"\u003e Bar.add(Foo) was called\");\n\n        BarFoo\n    }\n}\n\nfn main() {\n    println!(\"Foo + Bar = {:?}\", Foo + Bar);\n    println!(\"Bar + Foo = {:?}\", Bar + Foo);\n}\n```\n\n## Drop\n\n```rust\nstruct Droppable {\n    name: \u0026'static str,\n}\n\n// 这个简单的 `drop` 实现添加了打印到控制台的功能。\nimpl Drop for Droppable {\n    fn drop(\u0026mut self) {\n        println!(\"\u003e Dropping {}\", self.name);\n    }\n}\n\nfn main() {\n    let _a = Droppable { name: \"a\" };\n\n    // 代码块 A\n    {\n        let _b = Droppable { name: \"b\" };\n\n        // 代码块 B\n        {\n            let _c = Droppable { name: \"c\" };\n            let _d = Droppable { name: \"d\" };\n\n            println!(\"Exiting block B\");\n        }\n        println!(\"Just exited block B\");\n\n        println!(\"Exiting block A\");\n    }\n    println!(\"Just exited block A\");\n\n    // 变量可以手动使用 `drop` 函数来销毁。\n    drop(_a);\n    // 试一试 ^ 将此行注释掉。\n\n    println!(\"end of the main function\");\n\n    // `_a` *不会*在这里再次销毁，因为它已经被（手动）销毁。\n}\n```\n\n## Iterator\n\n```rust\nstruct Fibonacci {\n    curr: u32,\n    next: u32,\n}\n\n// 为 `Fibonacci`（斐波那契）实现 `Iterator`。\n// `Iterator` trait 只需定义一个能返回 `next`（下一个）元素的方法。\nimpl Iterator for Fibonacci {\n    type Item = u32;\n\n    // 我们在这里使用 `.curr` 和 `.next` 来定义数列（sequence）。\n    // 返回类型为 `Option\u003cT\u003e`：\n    //     * 当 `Iterator` 结束时，返回 `None`。\n    //     * 其他情况，返回被 `Some` 包裹（wrap）的下一个值。\n    fn next(\u0026mut self) -\u003e Option\u003cu32\u003e {\n        let new_next = self.curr + self.next;\n\n        self.curr = self.next;\n        self.next = new_next;\n\n        // 既然斐波那契数列不存在终点，那么 `Iterator` 将不可能\n        // 返回 `None`，而总是返回 `Some`。\n        Some(self.curr)\n    }\n}\n\n// 返回一个斐波那契数列生成器\nfn fibonacci() -\u003e Fibonacci {\n    Fibonacci { curr: 1, next: 1 }\n}\n\nfn main() {\n    // `0..3` 是一个 `Iterator`，会产生：0、1 和 2。\n    let mut sequence = 0..3;\n\n    println!(\"Four consecutive `next` calls on 0..3\");\n    println!(\"\u003e {:?}\", sequence.next());\n    println!(\"\u003e {:?}\", sequence.next());\n    println!(\"\u003e {:?}\", sequence.next());\n    println!(\"\u003e {:?}\", sequence.next());\n\n    // `for` 遍历 `Iterator` 直到返回 `None`，\n    // 并且每个 `Some` 值都被解包（unwrap），然后绑定给一个变量（这里是 `i`）。\n    println!(\"Iterate through 0..3 using `for`\");\n    for i in 0..3 {\n        println!(\"\u003e {}\", i);\n    }\n\n    // `take(n)` 方法提取 `Iterator` 的前 `n` 项。\n    println!(\"The first four terms of the Fibonacci sequence are: \");\n    for i in fibonacci().take(4) {\n        println!(\"\u003e {}\", i);\n    }\n\n    // `skip(n)` 方法移除前 `n` 项，从而缩短了 `Iterator` 。\n    println!(\"The next four terms of the Fibonacci sequence are: \");\n    for i in fibonacci().skip(4).take(4) {\n        println!(\"\u003e {}\", i);\n    }\n\n    let array = [1u32, 3, 3, 7];\n\n    // `iter` 方法对数组/slice 产生一个 `Iterator`。\n    println!(\"Iterate the following array {:?}\", \u0026array);\n    for i in array.iter() {\n        println!(\"\u003e {}\", i);\n    }\n}\n```\n\n## impl Trait\n\n如果函数返回实现了 `MyTrait` 的类型，可以将其返回类型编写为 `-\u003e impl MyTrait`。\n这可以大大简化你的类型签名！\n\n```rust\nuse std::iter;\nuse std::vec::IntoIter;\n\n// 该函数组合了两个 `Vec \u003ci32\u003e` 并在其上返回一个迭代器。\n// 看看它的返回类型多么复杂！\nfn combine_vecs_explicit_return_type(\n    v: Vec\u003ci32\u003e,\n    u: Vec\u003ci32\u003e,\n) -\u003e iter::Cycle\u003citer::Chain\u003cIntoIter\u003ci32\u003e, IntoIter\u003ci32\u003e\u003e\u003e {\n    v.into_iter().chain(u.into_iter()).cycle()\n}\n\n// 这是完全相同的函数，但其返回类型使用 `impl Trait`。\n// 看看它多么简单！\nfn combine_vecs(\n    v: Vec\u003ci32\u003e,\n    u: Vec\u003ci32\u003e,\n) -\u003e impl Iterator\u003cItem=i32\u003e {\n    v.into_iter().chain(u.into_iter()).cycle()\n}\n\nfn main() {\n    let v1 = vec![1, 2, 3];\n    let v2 = vec![4, 5];\n    let mut v3 = combine_vecs(v1, v2);\n    assert_eq!(Some(1), v3.next());\n    assert_eq!(Some(2), v3.next());\n    assert_eq!(Some(3), v3.next());\n    assert_eq!(Some(4), v3.next());\n    assert_eq!(Some(5), v3.next());\n    println!(\"all done\");\n}\n```\n\n```rust\n// 返回一个将输入和 `y` 相加的函数\nfn make_adder_function(y: i32) -\u003e impl Fn(i32) -\u003e i32 {\n    let closure = move |x: i32| { x + y };\n    closure\n}\n\nfn main() {\n    let plus_one = make_adder_function(1);\n    assert_eq!(plus_one(2), 3);\n}\n```\n\n```rust\nfn double_positives\u003c'a\u003e(numbers: \u0026'a Vec\u003ci32\u003e) -\u003e impl Iterator\u003cItem = i32\u003e + 'a {\n    numbers\n        .iter()\n        .filter(|x| x \u003e \u0026\u00260)\n        .map(|x| x * 2)\n}\n```\n\n## Clone\n\n```rust\n// 不含资源的单元结构体\n#[derive(Debug, Clone, Copy)]\nstruct Nil;\n\n// 一个包含资源的结构体，它实现了 `Clone` trait\n#[derive(Clone, Debug)]\nstruct Pair(Box\u003ci32\u003e, Box\u003ci32\u003e);\n\nfn main() {\n    // 实例化 `Nil`\n    let nil = Nil;\n    // 复制 `Nil`，没有资源用于移动（move）\n    let copied_nil = nil;\n\n    // 两个 `Nil` 都可以独立使用\n    println!(\"original: {:?}\", nil);\n    println!(\"copy: {:?}\", copied_nil);\n\n    // 实例化 `Pair`\n    let pair = Pair(Box::new(1), Box::new(2));\n    println!(\"original: {:?}\", pair);\n\n    // 将 `pair` 绑定到 `moved_pair`，移动（move）了资源\n    let moved_pair = pair;\n    println!(\"copy: {:?}\", moved_pair);\n\n    // 报错！`pair` 已失去了它的资源。\n    //println!(\"original: {:?}\", pair);\n    // 试一试 ^ 取消此行注释。\n\n    // 将 `moved_pair`（包括其资源）克隆到 `cloned_pair`。\n    let cloned_pair = moved_pair.clone();\n    // 使用 std::mem::drop 来销毁原始的 pair。\n    drop(moved_pair);\n\n    // 报错！`moved_pair` 已被销毁。\n    //println!(\"copy: {:?}\", moved_pair);\n    // 试一试 ^ 将此行注释掉。\n\n    // 由 .clone() 得来的结果仍然可用！\n    println!(\"clone: {:?}\", cloned_pair);\n}\n```\n\n## 父 trait\n\n```rust\ntrait Person {\n    fn name(\u0026self) -\u003e String;\n}\n\n// Person 是 Student 的父 trait。\n// 实现 Student 需要你也 impl 了 Person。\ntrait Student: Person {\n    fn university(\u0026self) -\u003e String;\n}\n\ntrait Programmer {\n    fn fav_language(\u0026self) -\u003e String;\n}\n\n// CompSciStudent (computer science student，计算机科学的学生) 是 Programmer 和 Student 两者的子类。\n// 实现 CompSciStudent 需要你同时 impl 了两个父 trait。\ntrait CompSciStudent: Programmer + Student {\n    fn git_username(\u0026self) -\u003e String;\n}\n\nfn comp_sci_student_greeting(student: \u0026dyn CompSciStudent) -\u003e String {\n    format!(\n        \"My name is {} and I attend {}. My favorite language is {}. My Git username is {}\",\n        student.name(),\n        student.university(),\n        student.fav_language(),\n        student.git_username()\n    )\n}\n\nfn main() {}\n```\n\n## 消除重叠 trait\n\n```rust\ntrait UsernameWidget {\n    // 从这个 widget 中获取选定的用户名\n    fn get(\u0026self) -\u003e String;\n}\n\ntrait AgeWidget {\n    // 从这个 widget 中获取选定的年龄\n    fn get(\u0026self) -\u003e u8;\n}\n\n// 同时具有 UsernameWidget 和 AgeWidget 的表单\nstruct Form {\n    username: String,\n    age: u8,\n}\n\nimpl UsernameWidget for Form {\n    fn get(\u0026self) -\u003e String {\n        self.username.clone()\n    }\n}\n\nimpl AgeWidget for Form {\n    fn get(\u0026self) -\u003e u8 {\n        self.age\n    }\n}\n\nfn main() {\n    let form = Form{\n        username: \"rustacean\".to_owned(),\n        age: 28,\n    };\n\n    // 如果取消注释此行，则会收到一条错误消息，提示 “multiple `get` found”（找到了多个`get`）。\n    // 因为毕竟有多个名为 `get` 的方法。\n    // println!(\"{}\", form.get());\n\n    let username = \u003cForm as UsernameWidget\u003e::get(\u0026form);\n    assert_eq!(\"rustacean\".to_owned(), username);\n    let age = \u003cForm as AgeWidget\u003e::get(\u0026form);\n    assert_eq!(28, age);\n}\n```\n"}]}},"page":"/[...param]","query":{"param":["data-type","interface"]},"buildId":"S-jJrz2DKYE9I2Mqo2Xou","assetPrefix":"/comparison-note","nextExport":true,"isFallback":false,"gip":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"接口/特征（interface/trait）"}]]}</script><script nomodule="" src="/comparison-note/_next/static/chunks/polyfills-7258ef49cf482e03ae9c.js"></script><script src="/comparison-note/_next/static/chunks/main-14614ae8e939b9e5961e.js" async=""></script><script src="/comparison-note/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/comparison-note/_next/static/chunks/framework.c7b20b4e446c7cca89e7.js" async=""></script><script src="/comparison-note/_next/static/chunks/7945cc82.ff5578978733a40a67a3.js" async=""></script><script src="/comparison-note/_next/static/chunks/commons.a32a113e095d8f0b1079.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/_app-1832d2b05f1f19d6a06d.js" async=""></script><script src="/comparison-note/_next/static/chunks/a1bc03cf.64f9f8493143216945e6.js" async=""></script><script src="/comparison-note/_next/static/chunks/4d6c67b811e74d3ca6630b1db854b02fef4ff3ce.8a4303f940dd12850a8f.js" async=""></script><script src="/comparison-note/_next/static/chunks/pages/%5B...param%5D-ec17b069b047a5ce78c3.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_buildManifest.js" async=""></script><script src="/comparison-note/_next/static/S-jJrz2DKYE9I2Mqo2Xou/_ssgManifest.js" async=""></script></body></html>